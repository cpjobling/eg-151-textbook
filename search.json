[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "",
    "text": "EG-151 Microcontrollers",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "index.html#croesowelcome",
    "href": "index.html#croesowelcome",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "Croeso/Welcome",
    "text": "Croeso/Welcome\nEG-151 Microcontrollers is a first year engineering course for those studying Electrical and Electronic Engineering and General Engineering which introduces basic microcontroller structure and operation designed to teach you both theoretical and practical skills in microcontrollers. It consists of an introduction to the Electronic and Electrical Engineering laboratory, a lecture course on the architecture and operation of the Atmel ATmega328 microcontroller (from Microchip Technology), and a series of Arduino programming laboratories culminating in a mini-project in which you will apply their experience to a simple practical problem.\nIn the website version of this textbook, the table of contents is in the left sidebar and the page contents is in the right sidebar.",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "index.html#tour-of-the-canvas-site",
    "href": "index.html#tour-of-the-canvas-site",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "Tour of the Canvas site",
    "text": "Tour of the Canvas site\nDuring the first class meeting we will introduce this online textbook and how the course materials are presented to you via Canvas.",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "index.html#pdf-version-of-this-web-site",
    "href": "index.html#pdf-version-of-this-web-site",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "PDF Version of this Web Site",
    "text": "PDF Version of this Web Site\nThere is a version of this site that is published as a textbook in PDF form. It can be downloaded from my shared OneDrive files as EG-151-Microcontrollers-2024-2025.pdf.\nThe PDF file linked to this page is updated automatically when the website is updated. It is also linked to the Canvas site. Please be aware that once downloaded, the PDF will no longer tack the website so you should always download the latest version before using it.",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "index.html#citing-this-document",
    "href": "index.html#citing-this-document",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "Citing this Document",
    "text": "Citing this Document\nWhen referencing this document please use the following format based on the library supported Swansea Vancouver Style (Anonymous 2024):\n\nJobling, C.P., Jahanger, H., Davies, T., Clifford, B. EG-151 Microcontrollers [Internet]. Swansea: Swansea University; 2024 August. [cited 2024 Mmm dd]; Available from; https://cpjobling.github.io/eg-151-textbook.\n\nTo cite a chapter, e.g. for a lab exercise, use the more precise citation, such as:\n\nDavies, T. Experiment 1: Binary Counter [Internet]. Swansea: Swansea University; 2024 August. EG-151 Microcontrollers [Internet]; 2024 August [cited 2024 Mmm dd]; [1 screen]. Available from; https://cpjobling.github.io/eg-151-textbook/labs/lab01/index.html.",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "index.html#colophon",
    "href": "index.html#colophon",
    "title": "EG-151 Microcontrollers 2024-2025",
    "section": "Colophon",
    "text": "Colophon\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n\n\n\nAnonymous. 2024. “LibGuides: Vancouver Referencing Guide (Online): Home — Libguides.swansea.ac.uk.” Swansea University: https://libguides.swansea.ac.uk/Vancouver.",
    "crumbs": [
      "EG-151 Microcontrollers"
    ]
  },
  {
    "objectID": "intro/course_aims.html",
    "href": "intro/course_aims.html",
    "title": "Course Aims",
    "section": "",
    "text": "EG–151 Microcontrollers aims to introduce you to laboratory work in Electronic and Electrical Engineering, the fundamentals of microcontroller structure and operation and to help you to develop skills in low-level programming language and project work.\nThere will be a lab introduction, an introduction to programming in the embedded C-language, an appreciation of low-level programming with assembly code, and opportunities to apply what you have learned to a simple microcontroller-driven instrumentation project.\n\n\n\nCopyright © 2021-2024 Swansea University. All rights reserved.",
    "crumbs": [
      "Course Introduction",
      "Course Aims"
    ]
  },
  {
    "objectID": "intro/course_delivery.html",
    "href": "intro/course_delivery.html",
    "title": "Course Delivery Method",
    "section": "",
    "text": "Live learning activities\nSee the Canvas calendar for timings of the live activities.",
    "crumbs": [
      "Course Introduction",
      "Course Delivery Method"
    ]
  },
  {
    "objectID": "intro/course_delivery.html#live-learning-activities",
    "href": "intro/course_delivery.html#live-learning-activities",
    "title": "Course Delivery Method",
    "section": "",
    "text": "Lectures and Office Hours\nThere will be one lecture a week on Tuesday at 11:00 am on the architecture of the target microcontroller. This will be delivered on-campus and will be supported by on-demand after-class formative tests which aim to reinforce the knowledge gained in lectures by means of retrieval practice.\nIn addition, there will be an online office hour at 1:00 pm on Tuesday for group activities in support of the lecture course which is designed to address the areas of difficulty that have been identified by the formative tests.\nThe resources for the lecture course are arranged by week in modules on Canvas and start at Week 1: Introduction to Microcontrollers and Microcontroller Architecture.\n\n\nLaboratory activities\n\nLaboratory training requirements\nIt is an accreditation requirement that you have demonstrated competence in C12 Workshop and practical skills (“The Accreditation of Higher Education Programmes (AHEP)” 2020, 36). To pass the module you must pass the laboratory training requirements.\nIn order to pass the laboratory training requirements, you are required to keep a full record of lab attendance and record the completion date of each lab exercise in your lab diary. This record will be regularly evaluated and signed off by the laboratory support staff during the lab sessions.\nThere will be two COMPULSORY two-hour lab sessions per week on Thursdays and Friday 10:00-12:00. The department requires that each student has achieved at least 80% attendance (18 of 22 available sessions) in the lab. Catch-up sessions are provided for labs missed for valid reasons.\n\n\nLaboratory introduction\nLaboratory sessions during the first four weeks of term will be used for a laboratory introduction exercise.\nThe laboratory introduction must be passed before you can continue to work in the laboratory.\nComponents of the laboratory introduction are as follows:\n\nHealth and safety and safe working in the electronics laboratory\nBreadboard construction exercise\nCircuit simulation exercise using National Instruments Multisim\nSoldering exercise\n\nThe maximum mark for the laboratory introduction is 15 awarded as follows:\n\nTesting of circuit using plug-in breadboard and National Multisim and answers to questions at the end of the laboratory introduction script – Max. 10 marks - Assessed by Lab Diary and a Canvas quiz.\nConstruction of Tic-Tac(R) box continuity tester – Max. 5 marks.\n\nMarking is done and feedback is given by the module coordinator and the chief electronics technician.\nThe course materials and guidance for the lab introduction module start at module EG-151: Laboratory Introduction on Canvas.\n\n\nMicrocontroller programming laboratories\nThere will be two two-hour microntroller programming lab sessions per week, and these will begin once the lab introduction has been completed which will be the end of week 4 at the latest.\nThe laboratory work will be assessed by means of a lab diary worth 20% of the module marks. The lab diary is to be updated during the lab sessions and will be submitted via a Canvas submission point in November.\nThe Microcontroller laboratories are found in the Microcontrollers Laboratory module on Canvas.\n\n\nMini project\nThere will be a mini project which is worth 30% of the marks and will be assessed by a demonstration of the completed project and a short report. The project is designed to be carried out using the resources of the laboratory kit, however additional components e.g. LEDs, resistors, push buttons and so on can be requested from the staff. A program will be provided as a starting point, and you will be required to add additional features as suggested in the project briefing. The mini project will be published in the Mini Projects 2024-2025 module on Canvas.\nWe anticipate starting the mini project at the start of week 9.",
    "crumbs": [
      "Course Introduction",
      "Course Delivery Method"
    ]
  },
  {
    "objectID": "intro/course_delivery.html#on-demand-learning-activities",
    "href": "intro/course_delivery.html#on-demand-learning-activities",
    "title": "Course Delivery Method",
    "section": "On-demand learning activities",
    "text": "On-demand learning activities\nKnowledge and understanding will be increased via retrieval practice based on weekly formative tests delivered in Canvas.",
    "crumbs": [
      "Course Introduction",
      "Course Delivery Method"
    ]
  },
  {
    "objectID": "intro/course_delivery.html#class-test",
    "href": "intro/course_delivery.html#class-test",
    "title": "Course Delivery Method",
    "section": "Class test",
    "text": "Class test\nThe lecture course and the laboratory work will be assessed by an online class test worth 35%. We anticipate that the class test will be held between 11 am – 1 pm Tuesday 3rd December in Y Twyni PC Lab 104 in Week 10 with a resit being held in week commencing 20th January 2025.\n\n\n\n\n“The Accreditation of Higher Education Programmes (AHEP).” 2020. The Engineering Council; \n                  https://www.engc.org.uk/media/3464/ahep-fourth-edition.pdf. 2020.",
    "crumbs": [
      "Course Introduction",
      "Course Delivery Method"
    ]
  },
  {
    "objectID": "lectures/intro.html",
    "href": "lectures/intro.html",
    "title": "EG-151 Microcontrollers—Module Staff",
    "section": "",
    "text": "Dr Chris Jobling\nModule Coordinator\nEmail: c.p.jobling@swansea.ac.uk\nOffice Hour: Tuesdays 13:00 on Zoom. (From Monday 8th October)\nOffice Location: Room B206, Engineering East",
    "crumbs": [
      "Microcontrollers Lectures",
      "EG-151 Microcontrollers&mdash;Module Staff"
    ]
  },
  {
    "objectID": "lectures/intro.html#welcome:course_site",
    "href": "lectures/intro.html#welcome:course_site",
    "title": "EG-151 Microcontrollers—Module Staff",
    "section": "Course Site",
    "text": "Course Site\n\nThe home page for this course is “2425_EG-151_Microcontrollers” on your Canvas dashboard.\n\n\n\n\n\n\n\nFigure 1: The course entry page on Canvas dashboard",
    "crumbs": [
      "Microcontrollers Lectures",
      "EG-151 Microcontrollers&mdash;Module Staff"
    ]
  },
  {
    "objectID": "lectures/intro.html#welcome:course_delivery",
    "href": "lectures/intro.html#welcome:course_delivery",
    "title": "EG-151 Microcontrollers—Module Staff",
    "section": "Course Delivery",
    "text": "Course Delivery\n\nLecture Class\n\nTuesday 11:00 – 11:50\nGreat Hall, Room 029\n\nLaboratory class\n\n10:00 – 12:00 Thursday and Friday\nEngineering East, Room B107 Electronics Lab\n\nSelf Directed Learning (50 Hours over 10 Weeks)\n\nReview lecture material and supporting content\nOnline activities including quizzes and discussion forums",
    "crumbs": [
      "Microcontrollers Lectures",
      "EG-151 Microcontrollers&mdash;Module Staff"
    ]
  },
  {
    "objectID": "lectures/intro.html#welcome:course_overview",
    "href": "lectures/intro.html#welcome:course_overview",
    "title": "EG-151 Microcontrollers—Module Staff",
    "section": "Course Overview",
    "text": "Course Overview\nThis course is made up of lectures which introduce the basics of microcontroller architecture and operation, and how they are programmed\n\n\nCourse syllabus\nApplications of microcontrollers, and programming in both assembly and ‘C’ languages. The lectures will be supported by a series of practical sessions where you will learn how to implement the lecture content to commission simple programs on an Arduino microcontroller.\n\n\n\nKey Topics\n\n\nMicrocontroller fundamentals and architecture.\nMicrocontroller programming: instruction execution; basic instructions.\nSoftware design and development tools.\nAssembly and C programming languages.\n\n\n\n\n\nCourse Assessment\nThere are five formal assessment components to this course:\n\n\n1. Laboratory Training Requirements (Pass/Fail)\n\nIt is an accreditation requirement that you have demonstrated competence in C12 Workshop and practical skills. To pass the module you must pass the laboratory training requirements. In order to pass the laboratory training requirements, you are required to keep a full record of lab attendance and record the completion date of each lab exercise in your lab diary. This record will be regularly evaluated and signed oﬀ by the laboratory support staﬀ during the lab sessions.\nThere will be two COMPULSORY two-hour lab sessions per week on Thursdays and Friday 10:00-12:00. The department requires that each student has achieved at least 80% attendance (18 of 22 available sessions) in the lab. Catch-up sessions are provided for labs missed for valid reasons.\n\n\n\n\n\n2. Lab introduction exercise – 15%\n\nDuring the first four weeks of term, the laboratory will be used for a laboratory introduction exercise covering health and safety, a breadboard construction exercise, a simulation exercise and a soldering exercise.The laboratory introduction is COMPULSORY and must be passed if a student is to work in the laboratory.\n\n\n\n\n\n3. Five short ‘C’ language programming exercises – 20% (4% each)\n\nAn example program will be provided which students are expected to modify so as it performs the required functions. The 5 exercises involve creating a binary counter, reading a digital input, reading an analogue input and working with arrays, and writing information to an LCD display device.\nAssessment will be through submission of a lab diary containing the modified and commented code, a flow chart and a description of the changes made. Submission will be through the Canvas platform.\n\n\n\n\n\n4. A mini project – 30%\n\nThe mini project will require each student to create a program to achieve a certain task making use of the knowledge gained during the lectures and four lab exercises. Assessment will be through submission of a lab diary containing the modified and commented code, a flow chart and a description of the changes made. Submission will be through the Canvas platform.\n\n\n\n\n\n5. Formal Class Test – 35%\n\nThe class test will be online and based on content covered in the lectures and laboratory sessions.These questions will be similar to those presented in each weekly quiz. For the practical assessment marks to count, you must achieve at least 40% in the Formal Test.You will have one attempt to redeem a failure before the end of semester 1. If you achieve less than 40% after this, then the course mark will be just the Class Test mark and you will be required to sit a supplementary exam in August.\n\n\n\n\n\n\nLab attendance\nAdditionally, to be allowed a supplementary examination for this course you must have an 80% attendance rate in laboratory classes.",
    "crumbs": [
      "Microcontrollers Lectures",
      "EG-151 Microcontrollers&mdash;Module Staff"
    ]
  },
  {
    "objectID": "lectures/week01/index.html",
    "href": "lectures/week01/index.html",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "",
    "text": "50 years of teaching microprocessors at Swansea!",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#week1:introduction",
    "href": "lectures/week01/index.html#week1:introduction",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "",
    "text": "Dr Davies in the Electronics lab\n\n\n\n\nA brief history by our former colleague, Honoury Lecturer Dr Timothy Davies.\n\n\nStarted in 1972/1973 by Prof. David Aspinall and Dr. Erik Dagless, using bespoke equipment based on the Intel 8008.\nAlways using 8-bit micros such as Intel 8008, Intel 8085, Motorola 68HC11, Motorola 68HCS08…\nTake-home lab, developed by Dr Davies, in 2020, used the Arduino Nano which is based on the Atmel (now MicroChip) ATmega328\n\n\n\n\n\nOne of our former students, Prof Sir Andy Hopper, asked why we are not teaching using the ARM processor which he helped develop.\nSpring 2021 - the launch of a new microcontroller, the RP2040 which is packaged into a small module, costing only three pounds.\nThis is the microcontroller for our second-year EG-252 lab and is also used in the third-year module EG-3082 Embedded Systems launching this year,\nYou will therefore be using microcontrollers throughout this program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#week1:intro",
    "href": "lectures/week01/index.html#week1:intro",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "Introduction",
    "text": "Introduction\nIn this week’s lecture, you will be given an introduction to microcontrollers focusing on what a microcontroller is, where they can be found and how they can be described using the their architecture. The lecture then moves on to introduce the Atmel ATmega328 microcontroller, which will be used in the practical sessions in this course, looking at its core architecture including the function of the arithmetic logic unit and registers.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#week1:toc",
    "href": "lectures/week01/index.html#week1:toc",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "Topics Covered in this Lecture",
    "text": "Topics Covered in this Lecture\n\n\n\n\n\nSection 1.1: What is a Microcontroller?\nSection 1.2: Where are Microcontrollers Used?\nSection 1.3: How do we Describe Microcontrollers?\nSection 1.4: The Atmel ATmega 328 Microcontroller",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#sec-week1-what-is-a-uc",
    "href": "lectures/week01/index.html#sec-week1-what-is-a-uc",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "1.1 What is a Microcontroller?",
    "text": "1.1 What is a Microcontroller?\n\n\n\nA microntroller is a compact integrated circuit designed to govern a specific operation or set of operations within an embedded system.\nAt a high level of abstraction, a microntroller includes three core components within a single chip:\n\nA central processing unit (CPU)\nMemory, and\nInput/output (I/0) peripherals",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#sec-week1-where-are-uc-used",
    "href": "lectures/week01/index.html#sec-week1-where-are-uc-used",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "1.2 Where are Microcontrollers Used?",
    "text": "1.2 Where are Microcontrollers Used?\n\n\n\n\n\n\nFigure 1.1: Some industrial uses of microcontrollers\n\n\n\n\nMicrocontrollers are used in the automotive industry, consumer electronics, industrial and control systems, and environmental monitoring and many other areas of engineering.\n\n\n\n1.2.1 Automotive applications\n\n\n\n\n\n\nFigure 1.2: Automotive applications of microcontrollers1\n\n\n\n\nApplications of microcontrollers in the automotive industry\n\n\n\n\n\n\nEngine Control\n\n\nHeating/Cooling\n\n\nCentral Locking\n\n\nNavigation\n\n\nCruise Control\n\n\nLighting\n\n\nRadio\n\n\nCharging System\n\n\n\n\n\n\n\nExhaust Control\n\n\nParking Assistance\n\n\nWipers\n\n\nOccupancy / Airbags\n\n\nADAS\n\n\nCollison Warning\n\n\nSpeed limiter\n\n\nBattery Monitoring\n\n\n\n\n\n\n\n\n\n\n1.2.2 Consumer electronics\n\n\n\n\n\n\nFigure 1.3: Photograph showing the microcontroller inside a smart watch2\n\n\n\n\nApplications of microcontrollers in consumer electronics\n\n\n\n\n\nSmart watch\n\n\nMobile phone\n\n\nAir conditioner\n\n\nPrinter\n\n\nCalculator\n\n\nHair dryer\n\n\n\n\n\n\n\nAlarm clock\n\n\nMicrowave\n\n\nWipers\n\n\nFridge freezer\n\n\nPower tool\n\n\nRemote control\n\n\n\n\n\n\n\n\n\n1.2.3 Industrial applications\n\n\n\n\n\n\nFigure 1.4: Photograph showing robots working on an automated assembly line3\n\n\n\n\nApplications of microcontrollers in manufacturing systems\n\n\n\n\n\nManufacturing systems\n\n\nQuality control\n\n\nProcess monitoring\n\n\nRobotics\n\n\nTracking systems\n\n\nFire control\n\n\n\n\n\n\n\nMaterials processing\n\n\nLaboratory equipment\n\n\nMachine-to-machine communications\n\n\nNetworking\n\n\nSmart buildings / BMS\n\n\nEnvironmental control\n\n\n\n\n\n\n\n\n\n1.2.4 Environmental monitoring\n\n\n\n\n\n\nFigure 1.5: Environmental monitoring in Germany4\n\n\n\n\nApplications of microcontrollers in environmental monitoring\n\n\n\n\n\nAir quality monitoring\n\n\nWeather monitoring\n\n\nGas sensors\n\n\nWater quality sensors\n\n\nFarming\n\n\n\n\n\n\nTemperature monitoring\n\n\nLight level monitoring\n\n\nClimate change\n\n\nAir flow\n\n\nAnimal/wildlife tracking\n\n\n\n\n\n\n\n\n\n1.2.5 Microcontroller Market Forecast\n\n\n\n\n\n\nFigure 1.6: Microntroller (MCU) market size, 2021 to 2030 (Billion USD)5",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#sec-week1-architecture",
    "href": "lectures/week01/index.html#sec-week1-architecture",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "1.3 How do we Describe Microcontrollers?",
    "text": "1.3 How do we Describe Microcontrollers?\n\n\n1.3.1 Architecture\nDefinition from the Oxford English Dictionary architecture\n\nComputing. The conceptual structure and overall logical organization of a computer or computer-based system from the point of view of its use or design; a particular realization of this6.\n\n\n\n1.3.1.1 Number of Bits\n\n\n\n\n\n\nFigure 1.7: Architecture diagram showing number of bits used in a microcontroller\n\n\n\n\nCategorizing Microcontroller Units (MCUs) as 8-, 16-, or 32-bit designs is one way of classifying their performance capabilities.\nThe number of bits identifies the size of the registers, the number of available memory addresses and the largest number that can be processed/represented.\nAs an example, in an 8-bit MCU\n\nEach register is 8-bits (or one byte) wide.\nThere are \\(2^8\\) (or 256) possible memory addresses\nThere are \\(2^8\\) integers that can be represented (0 to 255).\n\nMicrocontrollers with more bits, for example 16- and 32-bit MCUs have correspondingly more bits per register, more available memory addresses, and can handle larger numbers compared with their 8-bit counterparts.\nAn introduction to data representation follows in Introduction to Data Representation.\n\n\nFigure 1.8 shows the data memory map of the Atmel Atmega328 which is an 8- bit MCU.\n\nIt has \\(2^8\\) or 256 available memory addresses from 0x0000 – 0x00FF which covers:\n\n32 general purpose registers,\n64 I/O registers, and\n160 Extended I/O registers\n\n\n\n\n\n\n\n\nFigure 1.8: Memory map for the Atmel Atmega328 MCU\n\n\n\n\n\nApplications of 8-bit and 32-bit MCUs\n\n\n\n\n\n\nFigure 1.9: Venn diagram of the applications of the 8-bit MCU vs. the 32-bit MCU7\n\n\n\n\nThe plotting of the application benefits of the 8-bit MCU vs. the 32-bit MCU is best plotted on a Venn diagram as direct comparisons of all features combined are relative to tradeoffs. In general, the 8-bit MCU has been lower cost and smaller in size than the 32-bit MCU, but 32-bit MCUs are close to competing on cost and both have at least one “specimen” of a similarly minute physical size. In overall power consumption, the slower 8-bit MCUs will always trump the faster 32-bit MCUs as long as manufacturers stay on their game.\n\n\n\n\nMarket share of 8-bit, 16-bit and 32-bit MCUs in 2021\n\n\n\n\n\n\nFigure 1.10: Market share of 8-bit, 16-bit and 32-bit MCUs in 20218\n\n\n\n\n\n\n\n1.3.1.2 Memory\n\n\n\n\n\n\nFigure 1.11: Architecture diagram showing memory types used in microcontrollers\n\n\n\n\n\nEmbedded vs external memory\nMemory in modern microcontrollers can be classified as embedded or external dependent on whether this is physically located within the MCU itself or is connected separately.\n\nFor most microcontroller-based applications, the internal memory is enough. However, applications which gather or buffer large amounts of data may also need external memory in the form of SD cards, M.2 drives and similar.\nA Raspberry Pi 4 Model B is illustrated in Figure 1.12. It has both internal and external memory.\n\n\n\n\n\n\n\n\nFigure 1.12: Raspberry Pi 4 Model B9\n\n\n\n\n\n\nVolatile vs non-volatile embedded memory\nBroadly speaking embedded memory that is found in a microcontroller can be classified into two categories:\n\n\nVolatile: data is lost when power is removed – this is temporary storage.\nNon-volatile: data is retained when power is removed – this is permanent storage.\n\n\n\nVolatile and non-volatile memory can be further classified as illustrated in Figure 1.13.\n\n\n\n\n\n\nFigure 1.13: Classification of volatile and non-volatile memory.\n\n\n\n\n\n\n\n1.3.1.3 Instruction Set Architectures\n\n\nArchitecture diagram showing instruction sets used in microcontrollers\n\n\nThe instruction set architecture (ISA) describes the format and operation of instructions the microcontroller can perform and a microcontroller will often be categorized as having a RISC based or CISC based architecture.\n\n\n\n\nReduced instruction Set Computer (RISC)\nA RISC is a device with a small, highly optimized set of instructions which utilizes registers and a highly regular instruction pipeline, allowing instructions to be completed in a low number of clock cycles.\n\nIn short, several instructions may need to be run to perform a task and this may complicate the coding.\n\n\n\n\n\nComplex Instruction Computer (CISC)\nA CISC is a device in which single instructions can execute several low-level operations or are capable of multi-step operations or addressing modes within single instructions.\n\nIn CISC machines, a program may be easier to read by a human, but the timing will be irregular and difficult to debug or be monitored by a machine.\n\n\n\n\n\nExample\nAs an example, consider the case where you want to multiply two numbers stored at addresses 0x0010 and 0x0011 respectively.\n\nOn a RISC based architecture microcontroller the code would look something like:\nLDS r18, 0x0010\nLDS r19, 0x0011\nMUL r18, r19\n\n\nHowever, on a CISC based architecture machine the multiply instruction may be able to perform the memory access instructions within its execution, meaning the code would look like this:\nMUL 0x0010, 0x0011\n\n\n\n\n\n1.3.1.4 Memory Architectures\n\n\n\n\n\n\nFigure 1.14: Architecture diagram showing the memory architectures used in microcontrollers\n\n\n\n\nMemory architecture is a different concept from embedded and external and volatile and non-volatile memory. Memory architecture classifications describe where program instructions and data are stored and how they are accessed.\nThere are two categories, Von-Neumann and Harvard.\n\n\n\nVon-Neumann (Princeton) architecture\n\nIn a Von-Neumann architecture, the same memory and bus are used for both data and instructions used by the CPU and peripherals as illustrated in Figure 1.15.\n\n\n\n\n\n\n\nFigure 1.15: The Von Neumann architecture—data memory and program code use the same memory storage area and data busses\n\n\n\n\n\n\nHarvard architecture\n\nThe Harvard architecture stores machine instructions and data in separate memory units that are connected to the CPU and peripherals by different busses as illustrated in Figure 1.16.\n\n\n\n\n\n\n\nFigure 1.16: The Harvard architecture—data memory and program code use different memory storage areas and busses.\n\n\n\n\n\n\nModified Harvard architecture\n\nMost modern microcontrollers don’t have a physical separation between the memory spaces used by data and instructions, and therefore could be described as Von Neumann for this reason. However, since these microcontrollers often use separate busses for data and instructions as illustrated in Figure 1.17, a better way to represent these is as a modified Harvard architecture10.\n\n\n\n\n\n\n\nFigure 1.17: The Harvard architecture—data memory and programcode use the same memory storage area, but data and program addresses use separate busses to access the memory.\n\n\n\n\n\n\n\n\n1.3.2 How is a Microcontroller Described?\nIn summary, the final MCU classification shown in Figure 1.18 represents some of categories under microcontroller architecture which are focused around the system itself.\n\nThere are further classifications as you move towards either the circuit design or the embedded system application.\n\n\n\n\n\n\n\nFigure 1.18: Classification of microcontroller systems\n\n\n\n\n\n1.3.2.1 System or Core Architecure\nIn general, most microcontroller manufacturers will present a system wide, or core architecture in the form of a diagram which will appear early on in the data sheet for the device.\n\n\nAtmel ATMega328P AVR\n\nFor example, Figure 1.19 is taken from Atmel ATMega328 data sheet (Atmel 2015) and shows a block diagram of the Advanced Virtual RISC (AVR) architecture.\n\n\n\n\n\n\n\nFigure 1.19: Block Diagram of the AVR Architecture (Source: Figure 6.1, Page 9 of the Atmel ATMega328P data sheet (Atmel 2015))\n\n\n\n\n\n\nNXP HCS08 MCU\n\nAs another example, the block diagram shown in Figure 1.20 represents the architecture of the NXP (formally Motorola) HCS08 MCU.\nThis MCU, which was used on this module before the Arduino was adopted, does not have a bank of general purpose registers. Instead it has a single working register, known as the accumulator, which is involved in most computations that the MCU performs.\n\n\n\n\n\n\n\nFigure 1.20: Block Diagram of the NXP HCS08 Architecture",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#sec-atmel-atmega328",
    "href": "lectures/week01/index.html#sec-atmel-atmega328",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "1.4 The Atmel ATmega 328 Microcontroller",
    "text": "1.4 The Atmel ATmega 328 Microcontroller\n\n\n\n\n\n\nFigure 1.21: The Atmel® ATMega328/P is a low-power CMOS 8-bit microcontroller based on the AVR® enhanced RISC architecture.11\n\n\n\n\n\n1.4.1 Introducing the Atmel ATMega328 MCU\n\n\nThis is an 8-bit CMOS microcontroller based on the AVR® enhanced RISC architecture with 131 instructions.\nIt has 2KB of Internal SRAM, 32 KB of Flash Memory and 1 KB of EEPROM.\nIt has 32 General Purpose Registers.\nIt can achieve up to 20 MIPS at 20 MHz (maximum clock frequency).\nThere are 8 Analog I/O pins connected to 10-bit analogue to digital converter (ADC).\nThere are 22 Digital I/O pins (6 capable of pulse-width modulation (PWM)).\nThe AVR core uses a Harvard memory architecture – with separate memories and busses for program and data.\n\n\n\n\n1.4.1.1 Arithmetic Logic Unit\n\nThe Arithmetic Logic Unit (ALU) (Figure 1.22), is the part of the processor that performs arithmetic and logic operations on numbers from the storage area – it is essentially the “brain” of the microcontroller.\n\n\n\n\n\n\n\nFigure 1.22: General purpose arithmetic logic unit (ALU)\n\n\n\n\n\nOperation of the ALU\n\n\nFirst, numbers are read from storage into the ALU’s data input ports.\nOnce inside the ALU, they’re modified by means of an arithmetic or logic operation (ADD, SUB, AND, OR…)\nFlags are set in the Status Register according to the result of the operation.\nFinally, the data is written back to storage via the ALU’s output port.\n\n\n\n\n\nExample instruction\n\n\n\n\n\n\nFigure 1.23: Add without carry instruction for the ATMega328\n\n\n\n\n\n\nExample of the ALU from the 74LS181\nThe 74LS181 is a 4-bit microcontroller that supports 16 logical and 16 arithmetic operations.\n\nYou do not need to understand Figure 1.24, it is just and example to show that an ALU isn’t just a black box. Rather it contains complex logic circuitry by means of which it performs its operations.\n\n\n\n\n\n\n\nFigure 1.24: The ALU for the 74LS181 MCU\n\n\n\n\n\n\n\n\n1.4.2 Registers\nA register is a group of memory bits with special addressing characteristics which is often used for a particular purpose.\n\n\nIn most modern processors, regardless of architecture, data is loaded from a larger memory space into special registers where it is used for arithmetic operations, manipulation or testing by various machine instructions.\nData is then temporarily held in a register until it is overwritten, or the immediate instruction stores it back to main memory.\n\n\n\n\n\n\n\n\nFigure 1.25: Use of registers in ATMega328 programms\n\n\n\n\n\n1.4.2.1 Registers in the ATMega328 MCU\n\nThe Atmel ATmega328 is an 8-bit microcontroller and has 256 addressable registers within the user data space. The first 32 locations address the Register File, the next 64 location the standard I/O memory and then the remaining 160 locations for Extended I/O memory.\nFigure 1.8 summarizes the memory map of the ATMega328 MCU. Figure 1.26 shows part of the full memory map that is given in the Atmel ATMega280/P data sheet (Atmel 2015, 275–80).\n\n\n\n\n\n\n\nFigure 1.26: Part of the memory map of the Atmel ATMega328/P MCU\n\n\n\n\n\n\n1.4.2.2 The Register File\n\nThe register file (see Figure 1.27) contains 32 x 8-bit wide registers that are often referred to as general purpose or working registers in the CPU.\n\n\n\n\n\n\n\nFigure 1.27: The register file for the Atmel ATMega328/P MCU\n\n\n\n\nEach register is also assigned a data memory address, mapping them directly into the first 32 locations of the user data space.\nMost of the instructions operating on the Register File have direct access to all registers, and most of them are single cycle instructions, however:\n\nR0 – R15 are not available for all instructions, and\nR26 – R31 have some added functions as pointer registers.\n\n\n\n\n1.4.2.3 Using the Register File\n\nFigure 1.28 shows an extract from the documentation for the use of registers in the add without carry (ADD) operation. Figure 1.29 shows an extract from the documentation for the use of registers for a load immediate (LDI) operation.\n\n\n\n\n\n\n\nFigure 1.28: Using the registers for an ADD without carry operation\n\n\n\n\n\n\n\n\n\n\nFigure 1.29: Using the registers for an Load immediate (LDI) operation\n\n\n\n\n\n\n1.4.2.4 X- Y- Z-Pointer Registers\n\nIn addition to acting as general purpose registers, R27 - R31 can be used as 16-bit address pointers and referred to as the X-,Y-, Z-registers as illustrated in Figure 1.30. These pointers can be used to indirectly address the SRAM portion of the data space.\n\n\n\n\n\n\n\nFigure 1.30: The x-, y- and z- registers\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe start address of SRAM is 0x0100, this cannot be accessed with 8-bits (maximum is 0x00FF).\n\n\nWe will look at this in more detail at the end of the module but this approach can be useful to access sets of data where we don’t necessarily know the address.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#summary",
    "href": "lectures/week01/index.html#summary",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "Summary",
    "text": "Summary\nIn this lecture we have:\n\nFamiliarized ourselves with what a microcontroller is and where they are used.\nIntroduced describing a microcontroller by considering parts of its architecture and\nBegun to look at the Atmel ATmega328 microcontroller focusing on its register file and the general-purpose registers.\n\n\n\nOn Canvas\nThere is a Canvas quiz which tests your recall of the topics covered in this lecture.\n\n\n\nNext week\nNext week we will look at Data Representation.\n\n\n\n\n\nAtmel. 2015. Datasheet: ATmega328p: 8-Bit AVR Microntroller with 32K Bytes in-System Programming Flash (version 7810D–AVR–01/15). Microchip; \n                  https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf\n.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/week01/index.html#footnotes",
    "href": "lectures/week01/index.html#footnotes",
    "title": "1  Introduction to Microcontrollers and Microcontroller Architecture",
    "section": "",
    "text": "Source of original image used in Figure 1.2: www.linkedin.com/pulse/microcontrollers-used-automotive-applications-field-amin-agina. The original image is no longer accessible.↩︎\nSource of image used in Figure 1.3: www.electronicsweekly.com/blogs/distribution-world/communities/innovative-smartwatch-challenges-apples-watch-design-2015-10↩︎\nOriginal source of image used in Figure 1.4: investinfrance.fr/high-technology-industry/robotic-arm-catch-for-electronic-assembly-line-the-robot-for-sm/. This original image is no longer available online.↩︎\nSource of image used in Figure 1.5: www.openpr.com/news/1799966/hawa-dawa-installs-the-largest-air-quality-measurement-network↩︎\nSource of imaged used in Figure 1.6: www.precedenceresearch.com/microcontroller-mcu-market↩︎\n“architecture, n., sense 6”. Oxford English Dictionary, Oxford University Press, July 2023, https://doi.org/10.1093/OED/5575991854↩︎\nThe source of the Venn diagram used in Figure 1.9: http://lreese.dotsenkoweb.com/2017/07/31/iot-choosing-8-bit-vs-32-bit-mcus↩︎\nSource of image used in Figure 1.10: www.precedenceresearch.com/microcontroller-mcu-market↩︎\nSource of image used in Figure 1.12: www.hackatronic.com/raspberry-pi-4-specifications-pin-diagram-and-description.↩︎\nThis gets around the bottleneck that can occur using a Von-Neumann memory architecture with lower costs than having two separate memories.↩︎\nSource of Figure 1.21 is BregesT65421354, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Microcontrollers and Microcontroller Architecture</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html",
    "href": "lectures/data_representation/index.html",
    "title": "2  Introduction to Data Representation",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#week2:introduction",
    "href": "lectures/data_representation/index.html#week2:introduction",
    "title": "2  Introduction to Data Representation",
    "section": "",
    "text": "Presentation version of these notes.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis chapter is designed to reinforce the material to be introduced in Week 2 of EG-143 Digital Systems and so it will not be delivered as part of a formal lecture in EG-151 Microcontrollers.\nInstead, we have provided some self-study materials in the Canvas Pages Introduction to Data Representation and Two’s complement, BCD, Binary Fractions and A.S.C.I.I as well as in Appendix A: Other Data Representations.\n\n\n\n\n\n\nImportant\n\n\n\nThis material is examinable in EG-151 but there will not be a formal lecture. You should therefore read these notes for revision for the class test, try the execises and complete the quiz Quiz Week 1(b) - Data Representation.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#week2:toc",
    "href": "lectures/data_representation/index.html#week2:toc",
    "title": "2  Introduction to Data Representation",
    "section": "Topics Covered in this Lecture",
    "text": "Topics Covered in this Lecture\n\n\n\n\n\nSection 2.1 Data Representations\nSection 2.2 Numbering Systems and Base Conversion\nSection 2.3 Binary Addition and Subtraction\nSection 2.4 Introduction to the Status Register",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#sec-week2:intro2dr",
    "href": "lectures/data_representation/index.html#sec-week2:intro2dr",
    "title": "2  Introduction to Data Representation",
    "section": "2.1 Data Representations",
    "text": "2.1 Data Representations",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#sec-week2:numbering",
    "href": "lectures/data_representation/index.html#sec-week2:numbering",
    "title": "2  Introduction to Data Representation",
    "section": "2.2 Numbering Systems and Base Conversion",
    "text": "2.2 Numbering Systems and Base Conversion",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#sec-week2:addition_and_subtraction",
    "href": "lectures/data_representation/index.html#sec-week2:addition_and_subtraction",
    "title": "2  Introduction to Data Representation",
    "section": "2.3 Binary Addition and Subtraction",
    "text": "2.3 Binary Addition and Subtraction\nHow do computers add and subtract numbers?",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#sec-week2:sr",
    "href": "lectures/data_representation/index.html#sec-week2:sr",
    "title": "2  Introduction to Data Representation",
    "section": "2.4 Introduction to the Status Register",
    "text": "2.4 Introduction to the Status Register\nThe microcontroller has an 8-bit register containing a number of flags which can be set based on the condition of the microcontroller.\nThe status register for the Atmel ATMega328/P is illustrated in Figure 2.9.\n\n\n\n\n\n\nFigure 2.9: The Status Register of the Atmel ATMega328/P\n\n\n\n\n\n2.4.1 Status register flags associated with binary addition and subtraction\n\n\nThe Half Carry Flag H is set (to 1) if there was a carry from bit 3; it is cleared (set to 0) otherwise.\nThe Zero Flag Z is set if the result is 0x00000000; cleared otherwise.\nThe Carry Flag C is set if there was a carry from the most significant bit (MSB)6 of the result; cleared otherwise.\n\n\n\nWe will look at the status register in detail in Architecture of the Atmel ATmega 328 Microcontroller.\n\n\n\n\n2.4.2 Binary Arithmetic Example 14\nFigure 2.10 shows the condition of the status register after completing the addition from Example 14.\n\n\n\n\n\n\nFigure 2.10: The condition of the status register after completing the sum \\(110_{10} + 227_{10} = 337\\).",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#other-data-representations",
    "href": "lectures/data_representation/index.html#other-data-representations",
    "title": "2  Introduction to Data Representation",
    "section": "2.5 Other Data Representations",
    "text": "2.5 Other Data Representations\nWe have provided notes and videos that introduce other commonly used data representations in Appendix A: Other Data Representations.\n\n\n\n\n\n\nImportant\n\n\n\nThis chapter and Appendix A are examinable and you should study both as part of your preparation for the class test.\n\n\n\nNext\nIn the next lecture we will look at the Architecture of the Atmel ATmega 328 Microcontroller.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/data_representation/index.html#footnotes",
    "href": "lectures/data_representation/index.html#footnotes",
    "title": "2  Introduction to Data Representation",
    "section": "",
    "text": "Source of image used in Figure 2.2: SRAM vs DRAM : How SRAM Works? How DRAM Works? Why SRAM is faster than RAM?, All About Electronics - YouTube.↩︎\nNote that octal and hexadecimal are related to binary as in each case the base is a power of 2. In the case of octal \\(8 = 2^3\\) and hexadecimal \\(16 = 2^4\\).↩︎\nNote we have to introduce the letters A-F to represent the two-digit decinal numbers 10-15. Thus \\(\\textrm{A}_{16} = 10_{10}\\), \\(\\textrm{B}_{16} = 11_{10}\\), \\(\\textrm{C}_{16} = 12_{10}\\), \\(\\textrm{D}_{16} = 13_{10}\\), \\(\\textrm{E}_{16} = 14_{10}\\), \\(\\textrm{F}_{16} = 15_{10}\\),↩︎\nThe prefix 0b is used in C code and many other languages as the prefix for the text representation of a binary value. 0 is used for octal values and 0x for hexadecimal values. If there is no leading zero, the number is assumed to be decimal. However a number is defined in program code, the actual value stored in memory to represent that number will be a binary number.↩︎\nThe calculator app on both Windows and MacOS have a programmer view that makes it easy to confirm these results.↩︎\nThe most significant bit is the left most bit. It corresponds to the numerical value \\(2^7 = 128\\). For certain operations, it may also indicate a negative number.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to Data Representation</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html",
    "href": "lectures/week02/index.html",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "",
    "text": "Introduction\nIn Introduction to Microcontrollers and Microcontroller Architecture we described what a microcontroller is and looked at how one can be described by considering its architecture. We finished the lecture looking at The Atmel ATmega 328 Microcontroller which provides an overview of the AVR core architecture and we introduced the general purpose registers and the ALU.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#lecture-topics",
    "href": "lectures/week02/index.html#lecture-topics",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "Lecture Topics",
    "text": "Lecture Topics\n\n\n\n\n\nSection 3.1: Introducing the Atmel ATmega 328 MCU\nSection 3.2: The Status Register\nSection 3.3: The Program Counter\nSection 3.4: The Stack Pointer\nSection 3.5: Introduction to Microcontroller I/O",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#sec-week02-intro",
    "href": "lectures/week02/index.html#sec-week02-intro",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "3.1 Introducing the Atmel ATmega 328 MCU",
    "text": "3.1 Introducing the Atmel ATmega 328 MCU\n\nArchitecture of the Atmel ATmega 328 MCU\n\n\n\n\n\n\nFigure 3.1: The architecture of the Atmel ATMega328 Microcontroller\n\n\n\n\nReferring to Figure 3.1, we note that\n\n\nThis is an 8-bit CMOS microcontroller based on the AVR enhanced RISC architecture with 131 instructions\nIt has 2KB of Internal SRAM, 32 KB of Flash Memory and 1 KB of EEPROM\nIt has 32 General Purpose Registers\nIt can achieve up to 20 MIPS at 20 MHz (maximum clock frequency)\nThere are 8 Analog I/O Pins connected to 10-bit ADC\nThere are 22 Digital I/O Pins (6 capable of PWM)\nThe AVR core uses a Harvard memory architecture – with separate memories and buses for program and data.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#sec-week02-status-register",
    "href": "lectures/week02/index.html#sec-week02-status-register",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "3.2 The Status Register",
    "text": "3.2 The Status Register",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#sec-week02-program-counter",
    "href": "lectures/week02/index.html#sec-week02-program-counter",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "3.3 The Program Counter",
    "text": "3.3 The Program Counter",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#sec-week02-stack-pointer",
    "href": "lectures/week02/index.html#sec-week02-stack-pointer",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "3.4 The Stack Pointer",
    "text": "3.4 The Stack Pointer",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#sec-week02-io",
    "href": "lectures/week02/index.html#sec-week02-io",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "3.5 Introduction to Microcontroller I/O",
    "text": "3.5 Introduction to Microcontroller I/O",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week02/index.html#summary",
    "href": "lectures/week02/index.html#summary",
    "title": "3  Architecture of the Atmel ATmega 328 Microcontroller",
    "section": "Summary",
    "text": "Summary\nIn this chapter we have:\n\nIntroduced a few more parts of the AVR core, namely, the status register, program counter and stack pointer and how these are used under normal operation\nStarted to look at I/O on a microcontroller including the concept of pull up resistors as well as some of the specific registers used in the AVR core to enable the use of both input and output device\n\n\n\nOn Canvas\nCanvas module Week 2: Microcontroller Architecture and I/O, along with these notes, there is some additional self study material on canvas on page Week 2: Atmel ATmega328 Architecture Overview. This includes a video demonstration, from my former colleague Ben Clifford, of the various topics discussed in this session.\nThere is also a quiz on Microcontroller Architecture.\n\n\n\nAny Questions?\nPlease use the Course Question Board on Canvas or take advantage of the lecturers’ office hours.\n\n\n\nNext time\n\nIntroduction to Programming and Program Development\n\n\n\n\n\n\nAtmel. 2015. Datasheet: ATmega328p: 8-Bit AVR Microntroller with 32K Bytes in-System Programming Flash (version 7810D–AVR–01/15). Microchip; \n                  https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf\n.\n\n\n———. 2020. AVR(r) Instruction Set Manual (version DS40002198A). Microchip; \n                  https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/ReferenceManuals/AVR-InstructionSet-Manual-DS40002198.pdf\n.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Architecture of the Atmel ATmega 328 Microcontroller</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html",
    "href": "lectures/week03/index.html",
    "title": "4  Introduction to Programming and Program Development",
    "section": "",
    "text": "Introduction\nWhen developing an application to run on a microcontroller or other embedded system, there are five key steps which should be followed:",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-week03-intro",
    "href": "lectures/week03/index.html#sec-week03-intro",
    "title": "4  Introduction to Programming and Program Development",
    "section": "",
    "text": "Clearly define the requirements of the system, planning the number of inputs and outputs required, speed, storage etc. to identify suitable hardware candidates.\nPlan/design the software using flowcharts and pseudocode to describe the program and identify functions, or blocks of code, and how they link to other blocks.\nTranslate the flowchart into the required programming language.\nOnce the program is at a level where its functionality can start to be tested, testing and debugging is performed to look for errors or unexpected behaviour in software called bugs.\nWhen the final software is commissioned, it is important to document the code so as a developer can come back to it at later date or pass the task to another team member.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#lecture-topics",
    "href": "lectures/week03/index.html#lecture-topics",
    "title": "4  Introduction to Programming and Program Development",
    "section": "Lecture Topics",
    "text": "Lecture Topics\n\n\n\n\n\nSection 4.1: Useful Terminology\nSection 4.2: Programming Languages\nSection 4.3: Flowcharts\nSection 4.4: Example Programs\nSection 4.5: Modular Programming",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-week03-useful-terminology",
    "href": "lectures/week03/index.html#sec-week03-useful-terminology",
    "title": "4  Introduction to Programming and Program Development",
    "section": "4.1 Useful Terminology",
    "text": "4.1 Useful Terminology",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-week03-programming-languages",
    "href": "lectures/week03/index.html#sec-week03-programming-languages",
    "title": "4  Introduction to Programming and Program Development",
    "section": "4.2 Programming Languages",
    "text": "4.2 Programming Languages",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-week03-flowcharts",
    "href": "lectures/week03/index.html#sec-week03-flowcharts",
    "title": "4  Introduction to Programming and Program Development",
    "section": "4.3 Flowcharts",
    "text": "4.3 Flowcharts",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-example-programs",
    "href": "lectures/week03/index.html#sec-example-programs",
    "title": "4  Introduction to Programming and Program Development",
    "section": "4.4 Example Programs",
    "text": "4.4 Example Programs",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#sec-week03-modular-programming",
    "href": "lectures/week03/index.html#sec-week03-modular-programming",
    "title": "4  Introduction to Programming and Program Development",
    "section": "4.5 Modular Programming",
    "text": "4.5 Modular Programming",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#summary",
    "href": "lectures/week03/index.html#summary",
    "title": "4  Introduction to Programming and Program Development",
    "section": "Summary",
    "text": "Summary\nIn this chapter we have:\n\n\nDefined terminology relating to programming and looked at how languages can be classified as high or low based on the level of abstraction from the architecture it is to be run on.\nLooked at flowcharts defining the standard symbols and looking at how they are used to represent a program.\nLooked at some example programs presented as flow charts and in pseudo code.\nNoted that there may be more than one way to present a program to achieve the same results.\nIntroduced the use of sub-processes to allow modular programming for splitting up a program or repeating common elements.\n\n\n\n\n4.5.2 On Canvas\n\nThis week on the canvas course page, there is:\n\n\n\na short video by Ben Clifford providing more of an introduction to programming languages and the compilation process;\na discussion forum to talk about the Section 4.4.6;\nsome supplementary resources; and\na quiz to test your knowledge.\n\n\n\n\n\nAny Questions?\nPlease use the Course Question Board on Canvas or take advantage of the lecturers’ office hours.\n\n\n\n4.5.3 Next time\n\nIntroduction to Programming with C\n\n\n\n\n\n\nKerningham, Brian, and Dennis Ritchie. 1978. The C Programming Language. 1st ed. Prentice; Hall.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week03/index.html#footnotes",
    "href": "lectures/week03/index.html#footnotes",
    "title": "4  Introduction to Programming and Program Development",
    "section": "",
    "text": "In most programming languages, text is stored in memory as a sequence of binary codes which each represent the individual characters as in 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!'. Such a sequence is usually called a string.↩︎\nRepetition is used a lot in microcontroller programming.↩︎\nPseudocode is a formal text which is used to represent the operation of a section of code in a way that can be understood without needing to resort to formal rules of a programming language.↩︎\nIn science, computing, and engineering, a black box is a system which can be viewed in terms of its inputs and outputs (or transfer characteristics), without any knowledge of its internal workings. Its implementation is “opaque” (black). The term can be used to refer to many inner workings, such as those of a transistor, an engine, an algorithm, the human brain, or an institution or government.—Blackbox (Wikipedia)↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to Programming and Program Development</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html",
    "href": "lectures/week04/index.html",
    "title": "5  Introduction to Programming with C",
    "section": "",
    "text": "Introduction\nC is a high-level structured programming language which is often used for writing microcontroller applications. This weeks lecture will cover good coding practices, C language operators and how they can be grouped as well as flow control structures.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html#lecture-topics",
    "href": "lectures/week04/index.html#lecture-topics",
    "title": "5  Introduction to Programming with C",
    "section": "Lecture Topics",
    "text": "Lecture Topics\nIn this chapter we will be looking at how to produce clear well commented programs; data transfer, arithmetic, logic and relational operators; and flow control structures including if, switch-case, for and while.\n\n\n\n\n\nSection 5.1: C-language\n\nSection 5.1.1: Code formatting\nSection 5.1.2: Comments\nSection 5.1.3: Pre-processor directives\nSection 5.1.4: Statements\nSection 5.1.5: Variables\nSection 5.1.6: Operators\n\nSection 5.2: Flow control\n\nSection 5.2.3: If statement\nSection 5.2.4: Switch statement\nSection 5.2.5: While statement\nSection 5.2.6: For statement",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html#sec-wk4-c-language",
    "href": "lectures/week04/index.html#sec-wk4-c-language",
    "title": "5  Introduction to Programming with C",
    "section": "5.1 C-language",
    "text": "5.1 C-language\nCode Formatting, comments, pre-processor directives, statements and operators\n\n\n5.1.1 Code formatting\n\n\nWrite comments that explain what the program does.\nUse descriptive names for variables and functions.\nUse tabs to indent nested code blocks.\nGive each class/function one purpose.\nDelete unnecessary/redundant code.\nReadability is more important than cleverness.\nAdopt and maintain a consistent coding style.\nWrite good comments.\nRefactor, refactor, refactor.\nTake regular backups and implement version control.\n\n\n\n/*\n * This is a demonstration program for EG-151 microcontrollers that shows a tidy well commented program.\n * This program asks a user to input two numbers and uses the function findmax to determine which is the largest.\n *\n * Author: Ben Clifford\n * Date: 12/10/2019\n */\n\n// include library files\n#include &lt;stdio.h&gt; //Required for scanf and printf\n\n// main function\nint main(void) {\n    // Variable Declarations\n    int num1, num2, maxnum;\n    // Function Declarations\n    int findmax(int, int);\n\n    printf(\"Enter the first number: \");\n    scanf(\"%u\", &num1);\n    printf(\"Enter the second number: \");\n    scanf(\"%u\", &num2);\n\n    /* invoke the function findmax passing numl and num2\n     * as arguments and storing the result in the variable maxnum\n     */\n    maxnum = findmax(num1, num2);\n    printf(\"The maximum number is %u\", maxnum);\n}\n\n// findmax Function Definition\nint findmax(int x, int y) {\n    int maximum_number;\n    if (x &gt;= y) {\n        maximum_number = x;\n    }\n    else {\n        maximum_number = y;\n    }\n    return maximum_number;\n}\n\nExecute this code using onlinegdb.com\n\n\n\n\n5.1.2 C language comments\n\n\nComments are added to code in order to make the program easier to read and understand at a later time or by another reader.\nWhen the compiler is reading the file, the comments are ignored.\nComments must follow a set of rules and a particular format.\n\nIn the ‘C’ language comments are surrounded by /* comment */ and can span multiple lines\n… or start with // if they are on a single line.\n\n\n\n\n\n5.1.2.1 Examples of comments\n\nSingle line comment \\(\\rightarrow\\) typically found after a statement\n\n\nA = 10; // This line sets variable A to 10\n\n\nMulti line comment \\(\\rightarrow\\) typically used at the start of a program or to detail a block of code or a function\n\n\n/* \n * This comment \n * spans multiple lines \n */\n\n\n\n\n\n5.1.3 Pre-processor directives\n\n\nThe pre-processor is part of the compilation process and runs before the code is compiled.\nThe pre-processor looks for lines of code beginning with a # and evaluates them before compilation.\nThere are also a number of predefined macros which can be called and these are surrounded by “__” characters.\nThe most commonly used pre-processor directives, and also the ones we will be using, are #include and #define.\n\n\n\nSome pre-processor directives\n#include\n#define\n#undef\n#if\n#elif\n#endif\n#ifdef\n#ifndef\n#error\n__FILE__\n__LINE__\n__DATE__\n__TIME__\n__TIMESTAMP__\n# macro operator\n## macro operator\n\n\n\n5.1.3.1 The #include directive\nThe #include directive is used to include header files which contain declarations of existing and frequently used functions that can be substituted into your program.\n\nHeader files may contain custom function definitions, common functions, secondary data type definitions, etc.\n\n\n/* \n  This variant is used for system header files. \n  The pre-processor searches for a file named in a \n  standard list of system directories\n*/\n#include &lt;header_file.h&gt;\n\n\n/* \n   This variant is used for header files of your own program. \n   It searches for the file name first in the current directory, \n   then in the same directories used for system header files. \n*/\n#include “my_library.h”\n\n\n\n\n5.1.3.2 The #define directive\n\nThe #define directive is used to define a macro – when the macro name appears in code it will be replaced with the definition stated.\n\n\nExample 1: define a value for a symbol\n#define pi 3.1415\n\n\nIn this example the programmer is stating that the letters pi represent the number 3.1415. Now, in the program they can write\nA = pi * r * r;\nand after pre-processing the compiler will see\nA = 3.1414 * r * r;\n\n\nExample 2: define a block of reusable code\n#define cube(x) (x) * (x) * (x)\n\n\nIf the programmer writes:\nv = cube(2) // = 8\nThe compiler sees:\nv = (2) * (2) * (2)  // = 8\n\n\n\n\n\n5.1.4 Statements in C\n\n\nC functions are made up of statements, each of which is terminated with a semicolon ;.\nA statement is made up of at least one operator and some operands.\nOperands can be variables or data.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMissing the semicolon is one of the most common causes of compilation errors in C programming.\n\n\n\n\n\n5.1.4.1 C functions\nFigure 5.1 is a schematic diagram of the C function. You can think of it as something that takes some inputs (arguments) and returns some output.\n\n\n\n\n\n\nFigure 5.1: A schematic diagram of a function in C\n\n\n\n\n\n\n5.1.4.2 C code for a function\nA simple function is presented below.\n/* \n * This function is called a_function. \n * It takes no aguments (inputs).\n * It returns no output.  \n */\nvoid a_function(void)\n{\n    statement1;\n    statement2;\n}\n\n\n\n\n5.1.5 Variables in C\nThe term variable is used for a name which describes a memory address. These names follow the same naming convention as used for functions1.\n\nFor example, a variable named num1 describes a particular memory address at which the first number is found and a second variable num2 describes a second memory address while a third variable, total, is a third memory address.\n\n\nIn a function we may then have the following statements:\n\n\nnum1 = 10;\nnum2 = 20;\ntotal = num1 + num2; // 30!\n\n\nEach of the statements in the example above tells the computer system to assign/store a value into the memory address described by the variable. This is called assignment.\nAssignment statements use the equals (=) sign to assign the value on the right of = to the variable on the left of =2\n\n\n\n\n5.1.6 Operators in C\n\nEach statement or instruction is made up of operators and operands, where the operator represents an action and the operands represents the data.\n\n\nIn C, the operators can be split into four categories based on the type of actions that they perform3.\n\n\nThey are:\n\n\nData transfer operators\nArithmetic operators\nLogical operators\n\nBitwise logical operators\nRelational operators\n\nProgram control operators\n\n\n\nWe will consider each of these in the following sections.\n\n\n\n5.1.6.1 Data transfer operators in C\nIn the C language, the data transfer operations are mostly covered by assignment without ever having to deal directly with the registers.\n\nFor example:\na = 10;\nb = 20;\nsum = a + b;\nPTFD = sum; // output total to PORT F\n\n\nThis is because C ia high-level language and the compiler takes care of the details.\n\n\n\n\n5.1.6.2 Arithmetic operators in C\nThe order of arithmetic operations follow the BODMAS (BIDMAS) rules4.\n\n\n\n\nOperator\nUsed for\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n%\nModulus\n\n\n++\nIncrement\n\n\n--\nDecrement\n\n\n\n\n\n\nExamples\nAssume a, b, c and r = 2 are defined as variable of type integer (int)5.\n\na = r * 5 + 6 / 3;    // -&gt; a = 12;\n\n\nBrackets can be used to improve readability6\nb = (3.14 * r * r);   // -&gt; b = 12 not 12.56!   \n\n\nThere are also special operators like increment and decrement\nc = c++;  // -&gt; c = c + 1\nd = d--;  // -&gt; d = d - 1;\n\n\nAssume d to h are defined as integer variables (int) and i as a floating point number (float):\n\nd = 5 / 3;    // -&gt; d = 1:  gives the whole part of the fraction\ne = 5 % 3;    // -&gt; e = 2: gives thremainder of the fraction\nf = 6 % 3;    // -&gt; f = 0: gives 0 as there is no remainder\ng = 5.5 / 2;  // -&gt; g = 2: float is converted to int\nh = 5.5 % 2;  // -&gt; invalid – will not compile\ni = 5.5 / 2;  // -&gt; i = 1.75    - evaluates correctly if i is defined as a float \n\n\nThe same rules apply to multiplication operation.\n\n\n\n\n\n5.1.6.3 Logical operators in C\nLogical operators are used in expressions which return true (1) or false (0).\n\n\n\n\nOperator\nMeaning\n\n\n\n\n&&\nLogical and\n\n\n||\nLogical or\n\n\n! .\nLogical not\n\n\n\n\n\n\nExample of the and operator (&&)\n/* \n * If the voltage is greater than 10 and the\n * current is less than 20 the condition is true\n * and the value of the expression will be 1, \n * otherwise it is false and the value of the \n * expression will be 0.\n */\nif ((voltage &gt; 10) && (current &lt; 20)) {...}\n\n\n\nExample of the or operator (||)\n/*\n *  If the voltage is greater than 10 or the\n *  current is greater than 20 the condition is\n *  true and the value of the expression will be\n *  1, otherwise it is false and the expression \n *  will be 0.\n */\nif((voltage &gt; 10) || (current &gt; 20)) {...}\n\n\n\nExample of the not operator (!)\n/* \n *  The unary operator (!) is usually used to\n *  turn true into false and vice versa.\n */\nc = 0;  // -&gt; c = 0 which is \"false\"\nd = !c; // -&gt; d = 1 which is \"true\".\n\n\n\nBitwise logical operators in C\nIn addition to the logical operators designed to evaluate multiple conditions there are bitwise logical operators which operate on the binary digits (bits) of their operands.\n\n\n\n\nOperator\nUsed for\n\n\n\n\n&\nbitwise AND\n\n\n|\nbitwise OR\n\n\n^\nbitwise XOR\n\n\n~\nbitwise NOT\n\n\n&gt;&gt;\nshift right\n\n\n&lt;&lt;\nshift left\n\n\n\n\n\n\nExample of the bitwise and operator\n\nb = 0xA3 & 0xD5; // -&gt; b = 0x81\n\n\n\\[\n\\begin{array}{lrr}\n   & 1010 & 0011 \\\\\n\\& & 1101 & 0101 \\\\\\hline\n   & 1000 & 0001\n\\end{array}\n\\]\n\n\n\n\nExample of the bitwise or operator\n\nc = 0xA3 | 0xD5; // -&gt; b = 0xF7\n\n\n\\[\n\\begin{array}{lrr}\n   & 1010 & 0011 \\\\\n|  & 1101 & 0101 \\\\\\hline\n   & 1111 & 0111\n\\end{array}\n\\]\n\n\n\n\nExample of the bitwise not operator\n\nc = ~0xA3; // -&gt; c = 0x5C\n\n\n\\[\n\\begin{array}{lrr}\n\\sim & 1010 & 0011 \\\\\\hline\n     & 0101 & 1100\n\\end{array}\n\\]\n\n\n\n\nBitwise operators used for I/O ports\n\nThe use of these operators are important when working with microcontrollers, in particular in the case of I/O, as they can be used to mask bits of a port. This is useful in C as we have limited data transfer options, i.e. we have to read/write to an entire port (memory location) rather than an individual bit.\n\nPTAPE = 0x0F;       // bit pattern: 0000 1111\nPTAD = 0xF0;        // bit pattern: 1111 0000\nPTAD = PTAD | 0x0C; // bit pattern: 1111 1100\n\nSince XORing any bit with a 1 forces it to return the opposite value, it can be used to toggle the state of a port:\n\n\nportA = portA ^ 0xFF; // e.g. 0101 0110 -&gt; 1010 1001\n\n\n\n\n\nRelational operators in C\nThe final group of operators are the relational operators which are used to test a relationship between two variables or a variable and data.\n\n\n\n\nRelational operator\nMeaning\n\n\n\n\n==\nis equal to\n\n\n!=\nis not equal to\n\n\n&lt;\nis less than\n\n\n&lt;=\nis less than or equal to\n\n\n&gt;\nis greater than\n\n\n&gt;=\nis greater than or equal to\n\n\n\n\n\nExample: “is x equal to 2?” would be written as x == 27.\nRelational operators are most often used in the expressions used in the conditions of the flow control structures discussed in Section 5.2.\n\n\n\n\n\n5.1.6.4 Program control operators in C\nThese are discussed in Section 5.2.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html#sec-wk4-flow-control",
    "href": "lectures/week04/index.html#sec-wk4-flow-control",
    "title": "5  Introduction to Programming with C",
    "section": "5.2 Flow control",
    "text": "5.2 Flow control\nFlow control statements if, for, while, and switch",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html#summary",
    "href": "lectures/week04/index.html#summary",
    "title": "5  Introduction to Programming with C",
    "section": "Summary",
    "text": "Summary\nIn this section we have:\n\n\nCovered basic concepts in coding to create clear and concise code as well as how to add comments to key lines of a program.\nIntroduced and discussed the different operators available to the C language programmer including how they are categorized.\nLooked at the flow control statements available in the C language as well as how they are represented using flowchart diagrams and examples of the required syntax.\n\n\n\n\nOn Canvas\nOn the canvas course page, there is a series of short videos providing a history of the C language and a brief overview of programming paradigms as well as videos on functions and data type with a quiz to test your knowledge.\n\n\n\nAny Questions?\nPlease use the Course Question Board on Canvas or take advantage of the lecturers’ office hours.\n\n\n\nNext time\n\nInterfacing to digital I/O with C",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week04/index.html#footnotes",
    "href": "lectures/week04/index.html#footnotes",
    "title": "5  Introduction to Programming with C",
    "section": "",
    "text": "Similarly to a function these variable names need to be declared before their use indicating their data type. More on this can be found in the self-directed study material for on Canvas for this week.↩︎\nPlease do not confuse = in C with equality in mathematics. After assignment, the value in the variable can change. In mathematics \\(a = b\\) means that \\(a\\) is always equal to \\(b\\). If we change the value of \\(b\\), the value of \\(a\\) changes too. In C, a = b copies the current value of b into the storage assigned to a. If we change the value of b later, a will not change. To confuse matters still further, there is another use of the equals symbol: == means is equal to and is used in decision statements such as is num1 equal to num2?↩︎\nWe will see similar categories of operators when we come to look at assembly language. For example, for data transfer we have the register instructions LDI (load register immediate), LDS (load register from store), and STS (store register to store).)↩︎\nBODMAS is a mnemonic which stands for Backets, Operations, Division/Multiplication, Addition/Subtraction. It describes the order of calculation in an expression that involves operators. Brackets, which are considered first, are used to disambiguate expressions that would otherwise produce wrong results. For example a + b/c is intrepreted as \\(a + (b/c)\\) not \\((a + b)/c\\).↩︎\nAn integer type means the value is a whole number (not a fractional number) that can be positive, negative, or zero.↩︎\nThe execution of expression 3.14 * r * r would most likely result in a decimal (floating point) number. This would be truncated to an integer before it is assigned to b. This is a common cause of mathematical error in programming.↩︎\nImportant: don’t confuse the double equals sign (==) with =. The latter is used for assignment operations. That is (x = 2) is different from (x == 2).↩︎\nMost of the unconditional branching statements such as goto (for an unconditional branch to a label) and continue (to ignore a condition without breaking out of a loop) are rarely used in modern programs. The break statement is often used in switch statements and occasionally for breaking out of a loop when some exit condition is met.↩︎\nEach case must be a constant expression: i.e. a number or a character.↩︎\ni.e. avoids if – elseif – elseif – elseif – elseif – … – else↩︎\nin the C language a block is any sequence of statements surrounded by curly brackets { ... }↩︎\nIndeed most c-compilers produce equivalent code for for and while.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Programming with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html",
    "href": "lectures/week05/index.html",
    "title": "6  Interfacing to digital I/O with C",
    "section": "",
    "text": "Introduction\nIn this lecture we will be looking at two different approaches to reading and writing to ports on a microcontroller.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#sec-week05-intro",
    "href": "lectures/week05/index.html#sec-week05-intro",
    "title": "6  Interfacing to digital I/O with C",
    "section": "",
    "text": "The first approach discussed is using library files and predefined functions to control I/O ports as is conventionally done with the Arduino IDE.\nThe second approach will look at accessing I/O bits directly using bit masks to select the desired pins.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#lecture-topics",
    "href": "lectures/week05/index.html#lecture-topics",
    "title": "6  Interfacing to digital I/O with C",
    "section": "Lecture topics",
    "text": "Lecture topics\nWe begin by looking at digital inputs and outputs before moving onto to show a detailed example program implemented on the Atmel ATmega328 microcontroller.\n\n\n\n\n\nSection 6.1: How does I/O work using the Arduino IDE\nSection 6.2: Bitmasking\nSection 6.3: Digital I/O Example Program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#sec-wk5-arduino-ide",
    "href": "lectures/week05/index.html#sec-wk5-arduino-ide",
    "title": "6  Interfacing to digital I/O with C",
    "section": "6.1 How does I/O work using the Arduino IDE",
    "text": "6.1 How does I/O work using the Arduino IDE",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#sec-wk5-bitmasking",
    "href": "lectures/week05/index.html#sec-wk5-bitmasking",
    "title": "6  Interfacing to digital I/O with C",
    "section": "6.2 Bitmasking",
    "text": "6.2 Bitmasking",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#sec-wk5-digital-io-example",
    "href": "lectures/week05/index.html#sec-wk5-digital-io-example",
    "title": "6  Interfacing to digital I/O with C",
    "section": "6.3 Digital I/O Example Program",
    "text": "6.3 Digital I/O Example Program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#summary",
    "href": "lectures/week05/index.html#summary",
    "title": "6  Interfacing to digital I/O with C",
    "section": "Summary",
    "text": "Summary\nIn this section we have:\n\n\nBegun to look at I/O operations on the Atmel Atmega 328 microcontroller including the registers and checking/setting states based on flow control statements.\nIntroduced bit masking to read/write individual bits of a register without affecting the remaining bits.\nLooked at a detailed example program which uses the state of two pushbuttons to set whether an LED is illuminated or not.\n\n\n\n\nOn Canvas\nThis week on the canvas course page, you will find the sample programs from today’s lecture.\nLook through these and ensure you are confident in how they work and how the masks are defined.\nThere is also a short quiz to test your knowledge on these topics.\n\n\n\nAny Questions?\nPlease use the Course Question Board on Canvas or take advantage of the lecturers’ office hours.\n\n\n\nNext time\n\nInterfacing to Analogue I/O with C",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week05/index.html#footnotes",
    "href": "lectures/week05/index.html#footnotes",
    "title": "6  Interfacing to digital I/O with C",
    "section": "",
    "text": "Arduino.h and wiring_digital.c are hidden away in the installation folders for the Arduino IDE. The examples versions shown here are taken from the GitHub repository github.com/arduino/ArduinoCore-avr.↩︎\nTo see the full contents see: Arduino.h on GitHub.↩︎\nIn the case of I/O specific bits refers to individual I/O pins.↩︎\nPins D8 and D9 are respectively bits 0 and 1 of Port B.↩︎\nIdiomatic C often uses the shortcut PORTB |= 0x00000010; There are many such assignment operators in C. For example: +=, -=, &= etc. They all mean the same thing: var = var op argument. Internally, the C compiler treats both forms the same so their use is a matter of style. The full version is easier to read and understand. The shortcut is quicker to type, but arguably less easy to read and understand.↩︎\nIn this definition we use the qualifier volatile to inform the compiler that the variable value can be changed any time without any task given by the source code. Without this qualifier, depending on the optimisation level of the compiler this may result in code that doesn’t work as it doesn’t know the value can be changed by external sources. The asterisk symbol is used to denote a pointer, for now you do not need to know what this explicitly mean but in short a pointer is a variable whose value is the address of another variable, i.e., direct address of the memory location rather than a value.↩︎\nThe actual code is slightly different and if you are interested you can access it here: main.cpp. Note that the sketch function setup() is called once first, then loop() is called each time through the infinite loop.↩︎\nThe actual code is slightly different and if you are interested you can access it here: main.cpp. Note that the sketch function setup() is called once first, then loop() is called each time through the infinite loop.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interfacing to digital I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html",
    "href": "lectures/week06/index.html",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "",
    "text": "Introduction\nC is a high-level structured programming language which is often used for writing microcontroller applications. This lecture looks at how I/O operations are performed on analogue inputs.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#lecture-topics",
    "href": "lectures/week06/index.html#lecture-topics",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "Lecture topics",
    "text": "Lecture topics\n\n\n\n\n\nSection 7.1: What are analogue signals?\nSection 7.2: ADC Architecture\nSection 7.3: The Atmel ATmega328 Analog-digital-converter\nSection 7.4: Analogue I/O Example program\n\n\n\n\n\nOutline\nIn this lecture we will be looking at how we can read analogue signals into a microcontroller using an analogue to digital converter (ADC).\n\n\nWe begin by introducing analogue signals and the fundamental principals of an ADC.\nWe move on to look at the ADC contained on the Atmel ATmega328 microcontroller, focussing on the key registers and how to use them.\nWe conclude with an example program for the Atmel ATmega328 microcontroller which reads the voltage from a potentiometer and turns on some LEDs based on the voltage.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#sec-wk6-sect1",
    "href": "lectures/week06/index.html#sec-wk6-sect1",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "7.1 What are analogue signals?",
    "text": "7.1 What are analogue signals?",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#sec-wk6-sect2",
    "href": "lectures/week06/index.html#sec-wk6-sect2",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "7.2 ADC Architecture",
    "text": "7.2 ADC Architecture\n\n\n\n\n\n\nFigure 7.12: The architecture of the ADC system in the Atmel ATmega328 Processor (source ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061B, Page 247)\n\n\n\n\n\n7.2.1 ADC Components\nThe architecture of the Atmel ATmega328 is shown in Figure 7.12. It contains the following major components:\n\n\nMultiplexer2\nVoltage Reference\nDigital to Analogue Converter (DAC)\nSample and Hold Circuit\nControl and Result Registers\n\n\n\nThe most important components are described in more detail in the following sections.\n\n\n\n\n7.2.2 Architectures\nThere are several achitectures for ADCs summarized as:\n\n\nSigma-Delta (\\(\\Sigma-\\Delta\\))\nSuccessive Approximation Register (SAR)\nPipelined\nFlash\n\n\n\nEach has their own advantages and disadvantages in terms of price, conversion speed, noise and complexity as summarized in Figure 7.13.\n\n\n\n7.2.2.1 ADC Architecture vs Resolution and Sample Rate\n\n\n\n\n\n\nFigure 7.13: ADC Architecture vs Resolution and Sample Rate (Source calstate.edu)\n\n\n\n\nMost general-purpose microcontrollers contain SAR-based architecture ADCs.\n\n\n\n\n\n7.2.3 SAR based ADC Architecture\n\nSuccessive-approximation-register (SAR) ADCs are the most common architecture for medium-to-high-resolution applications with sample rates under 5 megasamples per second.\nThe SAR converter is essentially a binary search algorithm which compares the input to the ADC with the output from a digital to analogue converter (DAC) until the input matches the DAC output and the device is able to output the corresponding binary value.\nWhile the internal circuitry of the ADC may be running at several megahertz, the ADC sample rate is a fraction of that number due to the multiple step successive-approximation algorithm needed to convert the measured input to a binary number.\nThe SAR converter is at the heart of the ATmega328 microcontroller and is highlighted in Figure 7.14.\n\n\n\n\n\n\n\nFigure 7.14: Schematic diagram of the Atmel ATMega328 ADC system with the SAR highlighted.\n\n\n\n\n\n7.2.3.1 SAR based ADC Operation\n\nConsider the schematic diagram shown in Figure 7.15.\n\n\n\n\n\n\n\nFigure 7.15: Schematic diagram of the hardware used to achieve SAR conversion (image source: Analog Devices3).\n\n\n\n\n\n\n7.2.3.2 SAR operation\n\n\nThe analogue input signal is held by a track/hold circuit and fed as \\(V_\\mathrm{IN}\\) into a comparator.\nTo implement the binary search algorithm, the \\(N\\)-bit register is first set to mid-scale (that is the MSB is set to 1 and all other bits set to 0) so that the voltage at \\(V_\\mathrm{DAC} = V_\\mathrm{REF}/2\\).\nA comparison is then performed to determine if \\(V_\\mathrm{IN} \\le  V_\\mathrm{DAC}\\).\n\nIf \\(V_\\mathrm{IN} &gt;  V_\\mathrm{DAC}\\), the comparator output will be logic high (or 1), and the MSB of the \\(N\\)-bit register remains at 1.\nIf \\(V_\\mathrm{IN} &lt;  V_\\mathrm{DAC}\\), the comparator output is a logic low (0) and the MSB of the \\(N\\)-register is cleared to logic 0.\n\nThe SAR control logic then moves to the next bit along4, forces that bit high, and repeats the comparison. The sequence continues all the way down to the LSB (bit 0).\nOnce the input has been compared with the full \\(N\\)-bit register the conversion is complete and the \\(N\\)-bit digital word is sent to the ADC output register.\n\n\n\n\n\n7.2.3.3 4-bit SAR based ADC Example\n\n\n\n\n\n\nFigure 7.16: Example of the successive approximation method in action: a 4 bit ADC converting a signal for which \\(V_\\mathrm{IN}\\) is in “bin” 5.\n\n\n\n\nConsider Figure 7.16:\n\nBit 3 is set high (compare signal is \\(1000_2\\))\n\n\\(V_\\mathrm{IN} &lt; V_\\mathrm{DAC}\\) so the comparator output is low (0).\n\nBit 3 is set low and bit 2 is set high (compare signal is now \\(0100_2\\)).\n\n\\(V_\\mathrm{IN} &gt; V_\\mathrm{DAC}\\) so the comparator output is high (1).\n\nBit 2 remains high and now Bit 1 is set high too (compare signal is \\(0110_2\\)).\n\n\\(V_\\mathrm{IN} &lt; V_\\mathrm{DAC}\\) so the comparator output is low (0).\n\nBit 1 is set low and bit 0 is set high (compare signal is \\(0101_2\\))\n\n\\(V_\\mathrm{IN} &gt; V_\\mathrm{DAC}\\) so the comparator output is high (1).\n\n\nThe final output of the conversion is \\(0101_2 = 5/16 V_\\mathrm{REF} = 0.3125 V_\\mathrm{REF}\\).",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#sec-wk6-sect3",
    "href": "lectures/week06/index.html#sec-wk6-sect3",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "7.3 The Atmel ATmega328 Analog-digital-converter",
    "text": "7.3 The Atmel ATmega328 Analog-digital-converter",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#sec-wk6-sect4",
    "href": "lectures/week06/index.html#sec-wk6-sect4",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "7.4 Analogue I/O Example program",
    "text": "7.4 Analogue I/O Example program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#summary",
    "href": "lectures/week06/index.html#summary",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "Summary",
    "text": "Summary\nIn this section we have:\n\n\nDiscussed the differences between analogue and digital signals and the challenges in working with them.\nExplored analogue to digital conversion looking at the architectures and focusing on SAR based ADCs.\nContinued looking at I/O operations on the Atmel ATmega328 microcontroller focusing on analogue signals and using the ADC registers.\n\n\n\n\nOn Canvas\nThis week on the canvas course pages, you will find the sample program from today’s lecture, look through this and ensure you are confident in how it works and how the registers are set for analogue inputs and how masks are used for the digital outputs to the LEDS.\nThere is also a short quiz to test your knowledge on these topics.\n\n\n\nAny Questions?\nPlease use the Course Question Board on Canvas or take advantage of the lecturers’ office hours.\n\n\n\nNext time\n\nIntroduction to Assembly Language",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week06/index.html#footnotes",
    "href": "lectures/week06/index.html#footnotes",
    "title": "7  Interfacing to Analogue I/O with C",
    "section": "",
    "text": "Note the symbols \\(\\lfloor \\ldots \\rfloor\\) are called floor. They round a decimal number to the next lowest integer value. That is the decimal part is simply eliminated. Thus quantization is always going to choose the bin that is the closest to the truncated part of the decimal number.↩︎\nThe multiplexer allows multiple inputs to share one set of ADC hardware.↩︎\nUnderstanding SAR ADCs: Their Architecture and Comparison with Other ADCs, Analog Devices.↩︎\nThe “next bit along” will be the MSB-\\(1^\\mathrm{th}\\) bit. That is, for a 12-bit ADC, MSB is bit 11, and the next bit along will be bit 10. If the previous comparison produced a 1, the binary value we are testing is now \\(2^{11} + 2^{10} = 2048 + 1024 = 3072\\). If the comparison at the previous step was 0, the binary value we are testing is now \\(2^{10} = 1024\\). The corresponding values of \\(V_\\mathrm{DAC}\\) will now be either \\(3072/4096 V_\\mathrm{REF} = 0.75 V_\\mathrm{REF}\\) or \\(1024/4096 V_\\mathrm{REF} = 0.25 V_\\mathrm{REF}\\). This process continues until all bits have been considered.↩︎\nSPS = Samples per second.↩︎\nThe internal voltage reference options may not be used if an external reference voltage is being applied to the AREF pin of the microcontroller chip.↩︎\nThis bit is used for clock-based ADC operation when you need a controlled and predictable sampling rate.↩︎\nRecall that the ADC has a precision of up to 10 bits so two data registers are required. Register ADCL contains the least significant 8 bits, bits [0-7] and ACDH contains the most significant bits bit 8 and bit 9.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Interfacing to Analogue I/O with C</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html",
    "href": "lectures/week07/index.html",
    "title": "8  Introduction to Assembly Language",
    "section": "",
    "text": "Introduction\nSo far in this course a number of topics have been covered including\nIn this lecture we will study assembly language which is a low level language that provides a one-to-one mapping between mnemonic instructions and the machine code that is executed on the microcontroller.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#sec-wk7-intro",
    "href": "lectures/week07/index.html#sec-wk7-intro",
    "title": "8  Introduction to Assembly Language",
    "section": "",
    "text": "Introduction to Data Representation,\nArchitecture of the Atmel ATmega 328 Microcontroller,\nIntroduction to Programming and Program Development, and\nIntroduction to Programming with C.\n\n\n\n\n\nThis will allow you to see how complex high-level instructions and functions in C are written in assembly language and the final program that gets transferred to the microcontroller.\n\n\n\nTopics discussed\nIn this lecture we will present an introduction to assembly language, including program structure and syntax as well as operation classifications.\nWe will also revisit the Direct Port Manipulation in C example from Digital I/O Example Program and translate this into assembly language looking at some of the key instructions involved.\n\n\n\nContents\n\n\n\n\n\nSection 8.1: Machine Code and Assembly Language\nSection 8.2: Introduction to Assembly Language\nSection 8.3: Interfacing with Digital I/O example",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#sec-wk7-sect1",
    "href": "lectures/week07/index.html#sec-wk7-sect1",
    "title": "8  Introduction to Assembly Language",
    "section": "8.1 Machine Code and Assembly Language",
    "text": "8.1 Machine Code and Assembly Language",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#sec-wk7-sect2",
    "href": "lectures/week07/index.html#sec-wk7-sect2",
    "title": "8  Introduction to Assembly Language",
    "section": "8.2 Introduction to Assembly Language",
    "text": "8.2 Introduction to Assembly Language",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#sec-wk7-sect3",
    "href": "lectures/week07/index.html#sec-wk7-sect3",
    "title": "8  Introduction to Assembly Language",
    "section": "8.3 Interfacing with Digital I/O example.",
    "text": "8.3 Interfacing with Digital I/O example.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#summary",
    "href": "lectures/week07/index.html#summary",
    "title": "8  Introduction to Assembly Language",
    "section": "Summary",
    "text": "Summary\nIn this section:\n\n\nWe have introduced assembly language as a direct mapping of mnemonics to machine code.\nWe have explored the basic structure of an assembly language program including operator classification, operands and comments.\nFinally, we have revisited out digital switch example from C and looked at how this can directly translate to Assembly language and how it can be optimized using specific features of the Atmel ATmega328 microcontroller.\n\n\n\n\nOn Canvas\nThis week on the Canvas course pages, you will find the sample program from today’s lecture, look through this and ensure you are confident in how it works and how the masks are defined and registers set.\nThere is also a short quiz to test your knowledge on these topics.\n\n\n\nNext time\n\nMicrocontroller Architecture – Program Operation\n\n\n\n\n\nHyde, Randall. 2010. 2nd ed. No Starch Press.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week07/index.html#footnotes",
    "href": "lectures/week07/index.html#footnotes",
    "title": "8  Introduction to Assembly Language",
    "section": "",
    "text": "Programs are stored on a microcontroller as a series of binary codes located within sequential memory addresses. These instructions are executed in order, dictated by the program counter, unless an instruction modifies the program counter and changes the program flow e.g. for a function call.↩︎\nImage source: www.shutterstock.com/image-vector/binary-code-digital-numbers-green-background-1724376772.↩︎\nImage source www.shutterstock.com/search/confused+person.↩︎\nBecause each mnemonic is associated with a single machine code, it is also easy to convert machine code to assembly language. This is sometimes useful for debugging programs. It is known as disassembly.↩︎\nPlease don’t get carried away! There are few tasks for which the cost of not starting in a HLL is going to be paid back by writing complete programs in assembly code.↩︎\nAs assembly codes are generally less readable than higher level languages, like the C language, it is good practice to be very liberal with comments in assembly code programs.↩︎\nThe purpose of these assembly directives is to assign a meaningful name to a label, constant, data value (variable), or memory location.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introduction to Assembly Language</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html",
    "href": "lectures/week08/index.html",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#sec-wk8-intro",
    "href": "lectures/week08/index.html#sec-wk8-intro",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "",
    "text": "In Introduction to Microcontrollers and Microcontroller Architecture, we discussed some of the core components of a microcontroller’s architecture including the general purpose registers, status register, program counter and stack pointers.\nAside from the program counter, these are registers which the programmer can directly access and manipulate.\n\n\n\n\nIn this section, we will look at some of the other components in the microcontroller CPU including the control unit, clock, memory address register, memory data register, instruction register and decoder.\n\n\n\nAfter introducing these components an example program will be demonstrated that is written in C language, showing the translation to assembly language using the listing file, followed by an explanation of how the program is executed through the fetch-decode-execute cycle.\n\n\n\n\nContents\n\n\n\n\n\nSection 9.1: Architecture recap\nSection 9.2: Additional components\nSection 9.3: Fetch-Decode-Execute cycle\nSection 9.4: An Example Program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#sec-wk8-sect1",
    "href": "lectures/week08/index.html#sec-wk8-sect1",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "9.1 Architecture recap",
    "text": "9.1 Architecture recap",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#sec-wk8-sect2",
    "href": "lectures/week08/index.html#sec-wk8-sect2",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "9.2 Additional components",
    "text": "9.2 Additional components",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#sec-wk8-sect3",
    "href": "lectures/week08/index.html#sec-wk8-sect3",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "9.3 Fetch-Decode-Execute cycle",
    "text": "9.3 Fetch-Decode-Execute cycle",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#sec-wk8-sect4",
    "href": "lectures/week08/index.html#sec-wk8-sect4",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "9.4 An Example Program",
    "text": "9.4 An Example Program",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#summary",
    "href": "lectures/week08/index.html#summary",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "Summary",
    "text": "Summary\nIn this section we have:\n\n\nRecapped the core components of the AVR CPU including the ALU, general purpose registers, program counter, stack pointer and status register as well as their function in the microcontroller.\nLooked at the function of some of the other components within the CPU including the clock, memory address register, memory data register, instruction register and decoder.\nLooked at an example of what happens during program execution through the fetch-decode-execute cycle.\n\n\n\n\nOn Canvas\nThis week on the canvas course pages, you will find a short quiz to test your knowledge on these topics.\n\n\n\nNext time\n\nAddressing Modes\n\n\n\n\n\nAtmel. 2020. AVR(r) Instruction Set Manual (version DS40002198A). Microchip; \n                  https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/ReferenceManuals/AVR-InstructionSet-Manual-DS40002198.pdf\n.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week08/index.html#footnotes",
    "href": "lectures/week08/index.html#footnotes",
    "title": "9  Microcontroller Architecture – Program Operation",
    "section": "",
    "text": "The status and control register also contains bits that can change the operation of the microcontroller. For example the global interrupt enable bit is set if interrupts have been enabled. Interrupts will be discussed in EG-252 next year.↩︎\nThe duty cycle is \\(\\mu=T_\\mathrm{on}/\\left(T_\\mathrm{on}+T_\\mathrm{off}\\right)\\) and \\(\\mu = 0.5\\) (50%) if \\(T_\\mathrm{on}=T_\\mathrm{off}\\). That is for half of a cycle (i.e. for \\(T_\\mathrm{on}\\)s) it is in a high state and for the other half of the cycle (for \\(T_\\mathrm{off}\\)s) it is in a low state.↩︎\nIf the frequency is \\(x\\)MHz, then the microcontroller can execute \\(x\\) million instructions a second and each instruction takes 1/x microseconds to execute. Therefore, for the ATmega328 with internal clock the execution speed is 0.125\\(\\mu\\)s per instruction. For the ATmega328 on the Arduino nano it is half this.↩︎\nThe carry flag C comes from the status register.↩︎\nThis file is not completely accurate as the assembler used has assumed the memory space is 8-bits wide where as it is actually 16-bits wide. This means each memory address shown should be divided by 2.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Microcontroller Architecture – Program Operation</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html",
    "href": "lectures/week09/index.html",
    "title": "10  Addressing Modes",
    "section": "",
    "text": "Introduction\nIn this week’s lecture, you will learn more about assembly language and the diverse ways to access data dependent on what it is and where it is stored.\nThis is based around a concept known as addressing modes.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html#sec-wk9-intro",
    "href": "lectures/week09/index.html#sec-wk9-intro",
    "title": "10  Addressing Modes",
    "section": "",
    "text": "There are different ways in which an operand may be specified in an instruction depending on what it is and where it is located. Some operations require no operands and the data to be operated on is implied, in other cases operands can be constants, variables, arrays and memory locations all of which are accessed differently.\n\n\n\nTopics discussed\nIn this section we will review a number of different addressing modes relevant to the Atmel ATMega328 Microcontroller including, inherent, immediate, direct, indirect and relative.\n\n\n\nContents\n\n\n\n\n\nSection 10.1: What is an addressing mode?\nSection 10.2: Addressing modes on the Atmel ATmega328",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html#sec-wk9-sect1",
    "href": "lectures/week09/index.html#sec-wk9-sect1",
    "title": "10  Addressing Modes",
    "section": "10.1 What is an addressing mode?",
    "text": "10.1 What is an addressing mode?\n\n\nAn addressing mode is a way in which an operand is specified in an instruction and defines how the CPU finds it.\nThere are different ways in which an operand may be specified in an instruction depending on what it is and where it is located.\nSome operations require no operands and the data to be operated on is implied, in other cases operands can be constants, variables, arrays and memory locations – this is where addressing modes are used.\n\n\n\nThe six addressing modes found in the AVR architecture used by the Atmel ATmega328 family of processors are summarised in Figure 10.1.\n\n\n\n\n\n\n\n\nFigure 10.1: The six addressing modes of an AVR processor.\n\n\n\n\n\nThe memory address where data is stored is called the effective address of the operand and the addressing mode refers to the way in which the operand is specified and how the CPU accesses it.\n\n\nAddressing modes are an aspect of the instruction set architecture in most central processing unit (CPU) designs. The various addressing modes that are defined in a given instruction set architecture define how the machine language instructions in that architecture identify the operand(s) of each instruction. An addressing mode specifies how to calculate the effective memory address of an operand by using information held in registers and/or constants contained within a machine instruction or elsewhere.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html#sec-wk9-sect2",
    "href": "lectures/week09/index.html#sec-wk9-sect2",
    "title": "10  Addressing Modes",
    "section": "10.2 Addressing modes on the Atmel ATmega328",
    "text": "10.2 Addressing modes on the Atmel ATmega328\nThe AVR® Enhanced RISC microcontroller supports powerful and efficient addressing modes for access to the program memory (Flash) and Data memory (SRAM, Register file, I/O Memory, and Extended I/O Memory).\n\nThe Atmel ATmega328 microcontroller makes use of the following addressing modes:\n\n\nSection 10.2.1: Inherent/Implied Addressing\nSection 10.2.2: Register Direct (single and two-register) Addressing\nSection 10.2.3: I/O Direct Addressing\nSection 10.2.4: Data Direct Addressing\nSection 10.2.5: Immediate Addressing\nSection 10.2.6: Data Indirect Addressing\nSection 10.2.7: Relative Addressing\nProgram Addressing (Not covered)\n\n\n\nApart from program addressing, we will discuss each of these addressing modes in the following.\n\n\n\n10.2.1 Inherent Addressing Mode\n\nFor instructions that use inherent addressing, sometimes called implicit or implied addressing, the operands are not explicitly specified but are implied by the instruction1.\n\n\n\nExamples of inherent addressing\n\n\n\nListing 10.1: Examples of inherent addressing.\n\n\nSEN    ; Set Negative Flag in Status Register (SREG)\nCLN    ; Clear Nagative Flag in Status Register (SREG)\nNOP    ; No Operation (do nothing for one clock cycle)\n\n\n\n\n\nSince no additional clock cycles are required to fetch and move data around, this is the simplest and fastest addressing mode.\nSome of the AVR instructions that use inherent addressing are listed in Table 10.1.\n\n\n\n\nTable 10.1: AVR instructions that use inherent addressing\n\n\n\n\n\nMnemonic\nOperands\nDecription\n\n\n\n\nCLZ\n-\nClear Zero Flag in SREG\n\n\nSEI\n-\nGlobal Interrupt Enable\n\n\nCLI\n-\nGlobal Interrupt Disable\n\n\nSES\n-\nSet Sign Bit in SREG\n\n\nCLS\n-\nClear Sign Bit in SREG\n\n\nSEV\n-\nSet Two’s Complement Overflow bit in SREG\n\n\nCLV\n-\nClear Two’s Complement Overflow bit in SREG\n\n\nSET\n-\nSet T bit in SREG\n\n\nCLT\n-\nClear T bit in SREG\n\n\nSEH\n-\nSet Half Carry Flag in SREG\n\n\nCLH\n-\nClear Half Carry Flag in SREG\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMicrocontrollers that have single accumulators in place of a bank of general-purpose registers often have more instructions that use inherent addressing such as CLRA, DECA, INCA.\n\n\n\n\n\n\n\n10.2.2 Register Direct Addressing\n\nFor these operators, the operands are contained in registers in the register file. There are single register operators which operates on and returns the result to the destination register, known as Rd2.\n\n\nBecause the microcontroller can access the register file faster than memory, they are also fast instructions.\n\n\n\n10.2.2.1 Single Register Addressing (Rd)\n\nFor instructions that use single direct register addressing, the operand is contained in the destination register Rd as illustrated in Figure 10.2.\n\n\n\n\n\n\n\n\nFigure 10.2: Illustrating single register direct addressing: d is the register number and Rd is source of the operand and the destination of the result.\n\n\n\n\n\nExamples\n\n\n\nListing 10.2: Examples of single register direct addressing.\n\n\nDEC R16     ;Decrement R16\nINC R17     ;Increment R17\nCLR R16     ;Clear R16\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nRemember the operand represents the data so this addressing mode is accessing or acting on the data using only one of the general purpose registers but does not include any write back to SRAM/EEPROM.\n\n\n\n\n\n\n\n10.2.2.2 Two Register Addressing (Rd, Rr)\n\nFor instructions that use direct register addressing with two registers, the operand is contained in the source and destination registers Rr3 and Rd respectively. As a result of these operations is that the data in Rd is overwritten. This is illustrated in Figure 10.3.\n\n\n\n\n\n\n\n\nFigure 10.3: Illustrating register direct addressing with two registers: d is the source of the first operand, r is the source of the second operand. The result overwrites the data in register d.\n\n\n\n\n\nExamples\n\n\n\nListing 10.3: Examples of direct register addressing with two registers.\n\n\nADD R16, R17  ;Add the contents of R16 and R17. Return sum to R17.\nCP R16, R17   ;Compare the values of R16 and R17 - sets the Z, N flags in SR\nMOV R16, R17  ;Copy contents of R16 into R17\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAs with the previous addressing mode, this one is accessing or acting on the data in two of the general purpose registers and although it overwrites the data in Rd is also does not include any write back to SRAM/EEPROM.\nNote that the result of CP is the sign of R16 - R17. If the difference is zero the Z flag is set in the status register. If the difference is a negative number, the S (sign) flag will be set. If the difference is positive, no flags are set. Carry and half-carry flags are also set as appropriate. The CP operation is typically followed by one of the branch operations BEQ (branch if equal to zero), BLT (branch if less than zero), BGT (branch if greater than zero), etc. The operation CP plus branch is typically used in the compilation of logical comparisons in C’s if, else if, while, and for statements.\n\n\n\n\n\n\n\n\n10.2.3 I/O Direct Addressing\n\nWithin the user data space there are 64 I/O registers as well as 160 Extended I/O registers. The first 64 of these can be accessed using instructions such as IN and OUT using I/O direct addressing mode. In I/O direct addressing mode the operands contain the address A of one of the lower 64 I/O locations and a source (Rr) or destination register (Rd). This is illustrated in Figure 10.4.\n\n\n\n\n\n\n\n\nFigure 10.4: Illustrating I/O direct addressing: the source (or destination) will be from an I/O register. The destination (or source) will be one of the general purpose registers.\n\n\n\n\n\nExamples4\n\n\n\nListing 10.4: Examples of I/O direct addressing.\n\n\nIN R16, PIND     ;Load (input) the contents of PIND into R16\nOUT PORTC, R17   ;Store (output) the contents of R17 to PORTC\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBe aware that loading and storing data to these registers using instructions such as LD and ST must address these registers differently and does not use I/O direct addressing mode.\n\n\n\n\n\n\n\n10.2.4 Data Direct Addressing\n\nInstructions that use direct data addressing are two words (32-bits) in length, the first operand, Rr/Rd is one of the general-purpose registers and the second is 16-bit Data Address contained in the 16 LSBs of the two-word instruction. This is illustrated in Figure 10.5.\n\n\n\n\n\n\n\n\nFigure 10.5: Illustrating data direct addressing: the source (or destination) will be in memory. The destination (or source) will be one of the general purpose registers.\n\n\n\n\n\nExamples\n\n\n\nListing 10.5: Examples of direct data addressing.\n\n\nLDS R16, 0x0100   ;Load the contents of data space address hex 0100 into R16\nSTS 0x0101, R17   ;Store the contents of R17 to data space address hex 0101\n\n\n\n\n\n\n\n10.2.5 Immediate Addressing\n\nWith instructions that use immediate addressing the actual data to be used is included within the instruction itself as a constant value5. This is illustrated in Figure 10.6.\n\n\n\n\n\n\n\n\nFigure 10.6: Illustrating immediate addressing: the destination will be an one of the general purpose registers. The source will be a data value given in the instruction.\n\n\n\n\n\nExamples\n\n\n\nListing 10.6: Examples of immediate addressing.\n\n\nLDI R16, 0x5B   ;Load the hex value 5B into R16\nSUBI R17, 24    ;Subtract the decimal value 24 from the contents of R17\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSince the instruction already contains the data, this is a fast addressing mode and only takes one clock cycle to complete.\n\n\n\n\n\n\nImmediate vs Data Direct Addressing\n\nInstructions that use immediate addressing, take one clock-cycle to complete.\n\n\nFor example LDI - load immediate:\n\n\n\nInstructions that use register or data direct addressing, take two clock-cycles to complete.\n\nFor example LDS - load from store needs to load the operator and decode the register address, then load data from the data space into the register.\n\n\n\n\n\n\n10.2.6 Data Indirect Addressing\n\nWith instructions that use indirect data addressing the operand address is the contents of one of the X- Y- Z-pointer registers. This is illustrated in Figure 10.7.\n\n\n\n\n\n\n\n\nFigure 10.7: Illustrating indirect data addressing in which two registers provide the address in memory of the operand.\n\n\n\n\n\nExamples\n\n\n\nListing 10.7: Examples of indirect data addressing.\n\n\nLDS R26, 0x00\nLDS R27, 0x10 \n\nLD R18, X      ;Load R18 with data stored at the address in the X- pointer register\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis mode allows the address to be a run time computed value, whereas the direct address must be computed at compile time/assembly time/load time.\nThis has several important use cases including setting up storage for arrays or other structures in memory.\n\n\n\n\n\n\n10.2.6.1 Indirect Data Addressing with Displacement\n\nAs with indirect data addressing, the microcontroller makes use of the Y and/or Z pointers with an additional displacement to access data stored in the data space.\n\n\nThis is the best way to access an array of data and is illustrated in Figure 10.8.\n\n\n\n\n\n\n\n\nFigure 10.8: Illustrating indirect direct addressing with displacement.\n\n\n\n\n\nExamples\n\n\n\nListing 10.8: Examples of indirect data addressing.\n\n\nLDS R28, 0x00\nLDS R29, 0x10 \n\nLD R18, Y + 1      ;Load R18 with data stored at the address in the Y- pointer register with a displacement of 1\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis mode allows the address to be a run time computed value, whereas the direct address must be computed at compile time/assembly time/load time.\n\n\n\n\n\n\n\n10.2.6.2 Indirect Data Addressing with Increment/Decrement\n\nIndirect Data Addressing mode also supports Post-increment and Pre-decrement addressing.\n\n\n\nWith Data Indirect Addressing with Post-increment, the X-, Y-, or the Z-pointer is incremented after the operation.\nThe operand address is the content of the X-, Y-, or the Z-pointer before incrementing.\nWith Data Indirect Addressing with Pre-decrement, the X,- Y-, or the Z-pointer is decremented before the operation.\nThe operand address is the decremented contents of the X-, Y-, or the Z-pointer.\n\n\n\n\nExamples\n\n\n\nListing 10.9: Examples of indirect data addressing with increment/decrement.\n\n\nLD R16, Z+ ;Load R16 with data stored at the current address in the Z pointer register then increment the Z register\nLD R16, -Z ;Load R16 with data stored at the current address in the Z pointer register - 1\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis mode is useful for iterating through arrays of or sequentially stored linked data.\n\n\n\n\n\n\n\n\n10.2.7 Relative Addressing\n\nWith relative program memory addressing the operand contains a signed 12-bit offset value which during execution is added to the program counter to change the flow of the program.\n\n\nThe destination of the branch (effective address) instruction is calculated by adding the signed byte following the opcode (-2048 to +2047) to the PC content. This is illustrated in Figure 10.9.\n\n\n\n\n\n\n\n\nFigure 10.9: Illustrating relative addressing which adjusts the program counter and is typically used for branching.\n\n\n\n\n\nExamples\n\n\n\nListing 10.10: Examples of relative addressing.\n\n\nRJMP Label  ;Jump to the address specified by label\nRCALL Label ;relative call to an address (subroutine)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis addressing mode is used by instructions such as RJMP to modify the flow of a program, this typically is used in conjunction with test conditions or at the end of the code to make it loop back to the start.\n\n\n\n\n\n\n10.2.7.1 Relative Addressing Example\n\n\n\n\n\n\nFigure 10.10: An example to illustrate relative addressing\n\n\n\n\n\n\n\nListing 10.11: Assembly code for the example of relative addressing.\n\n\nLOOP:\n    SBIC PIND, 2\n    RJMP LED1\n\n    SBIC PINC, 3\n    RJMP LED2\n\n    IN R16, PORTB\n    ANDI R16, 0b11111100\n    OUT PORTB, R16\n    RJMP LOOP\n\nLED1:\n    SBI PORTB, 0\n    RJMP LOOP\n\nLED2: \n    SBI PORTB, 1\n    RJMP LOOP\n\n\n\n\nRJMP LED1 -&gt; 1100 kkkk kkkk kkkk\n\nis\nC006 = 1100 0000 0000 0110 -&gt; RJMP +6\n\n\n\n\n\n\n\n\nFigure 10.11: The program counter jumps 6 memory locations forward.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html#summary",
    "href": "lectures/week09/index.html#summary",
    "title": "10  Addressing Modes",
    "section": "Summary",
    "text": "Summary\nIn this section have reviewed different addressing modes supported by the AVR instruction set commenting on use cases and speed (in clock cycles) of their operation.\n\n\nOn Canvas\nYou should review Section 3 of the AVR instructions set manual (Atmel 2020) on program and data addressing modes. There is a short quiz covering the content of this chapter.\n\n\n\nNext Time - Class Test!\n\nIn preparation for the class test next week, you should review all the content covered in these lecture notes, self-directed study material and the lab classes.\n\n\nNote that the class test is closed-book but you have will access to the reference manuals mentioned in these notes.\n\n\n\n\n\nAtmel. 2020. AVR(r) Instruction Set Manual (version DS40002198A). Microchip; \n                  https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/ReferenceManuals/AVR-InstructionSet-Manual-DS40002198.pdf\n.",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lectures/week09/index.html#footnotes",
    "href": "lectures/week09/index.html#footnotes",
    "title": "10  Addressing Modes",
    "section": "",
    "text": "In inherent addressing the effective address that the operation acts on is the register itself.↩︎\nThe d in Rd is a number in the range 0-31.↩︎\nThe r in Rr is also a number in the range 0-31.↩︎\nNote: in these examples, the labels PIND and PORTC must have already been defined.↩︎\nthe value of the second operand of an operator with immediate addressing will be hard coded into the code and cannot be changed during the running of a program.↩︎",
    "crumbs": [
      "Microcontrollers Lectures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Addressing Modes</span>"
    ]
  },
  {
    "objectID": "lab_intro/assessment.html",
    "href": "lab_intro/assessment.html",
    "title": "Assessment of the Laboratory Introduction",
    "section": "",
    "text": "Start date: Thursday, 3rd October 2024\nThe laboratory introduction is assessed according to the following:\n\nHealth and safety and safe in the electronics laboratory.\nBreadboard construction exercise.\nTesting of the circuit using a plug-in breadboard and National Instruments Multisim.\nAnswers to questions at the end of the laboratory introduction script marked automatically by means of a Canvas quiz.\nConstruction of a Tic-Tac box continuity tester.\n\nMarking is done and feedback is given jointly by the module coordinator and the chief Electronics technician.\nSubmission components:\n\nLab diary with record of breadboard construction exercise and simulation (5 marks with formative feedback on diary entry)\nAnswers to questions - Canvas Quiz (5 marks)\nInspection of Tic-Tac box continuity tester (5 marks)\n\nDeadline for submission: 16:00 25th October 2024 Deadline for feedback: 15th November 2024 or fifteen working days after submission.\n\n\n\nCopyright © 2021-2024 Swansea University. All rights reserved.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Assessment of the Laboratory Introduction</span>"
    ]
  },
  {
    "objectID": "lab_intro/lab_work.html",
    "href": "lab_intro/lab_work.html",
    "title": "Laboratory Work in the Department of Electronic and Electrical Engineering",
    "section": "",
    "text": "The Electronics Laboratory was completely refurbished with new equipment in August 2015, following the move to the Bay Campus. The Laboratory is used extensively for practical work in the first and second years of the Electronic and Electrical Engineering degree programmes. For example, depending on your degree programme, in the first year of your studies, you will take part in the following activities in the Teaching Laboratory:\n\nEG-143 Digital Design experiments on combinatorial logic using MULTISIM.\nEG-151 Microcontrollers, a series of experiments on the use of microcontrollers.\nEG-152 Analogue Design, a programme of experiments to design a function generator.\n\nIn addition, there will be computer-based exercises to support some of the lecture courses. You may already be familiar with voltmeters, oscilloscopes, and other basic instruments. The objective of this exercise is to allow everyone to use the laboratory instruments in a straightforward experiment followed by a construction task.\n\n\n\nCopyright © 2021-2024 Swansea University. All rights reserved.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Laboratory Work in the Department of Electronic and Electrical Engineering</span>"
    ]
  },
  {
    "objectID": "lab_intro/lab_instruments.html",
    "href": "lab_intro/lab_instruments.html",
    "title": "Laboratory Instruments",
    "section": "",
    "text": "The Lab Instrumentation\nYou may find these video guides to the instruments used in the Electronics lab useful.\nFor more videos, see the SwanseaEEE YouTube channel.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Laboratory Instruments</span>"
    ]
  },
  {
    "objectID": "lab_intro/lab_instruments.html#sec-lab-intro-instrumentation",
    "href": "lab_intro/lab_instruments.html#sec-lab-intro-instrumentation",
    "title": "Laboratory Instruments",
    "section": "",
    "text": "Instrumentation Tutorial - Oscilloscope\nA video of how to use the oscilloscope. You can watch a shorter version on the YouTube channel.\n\n\n\n\nInstrumentation Tutorial - Oscilloscope\nDuration: 5:44   ### Instrumentation Tutorial - Power Supply {#sec-lab-instruments-power-supply}\nA video of how to use the Power Supply in the lab. You can watch a shorter version in the YouTube channel.\n\n\n\n\nInstrumentation Tutorial - Power Supply\nDuration: 3:17\n\n\nInstrumentation Tutorial - Multimeter\nA video of how to use the multimeter in the lab. You can watch a shorter version in the YouTube channel.\n\n\n\n\nInstrumentation Tutorial - Multimeter\nDuration: 1:55\n\n\nInstrumentation Tutorial - Signal Generator\nA video of how to use the signal generator in the lab. You can watch a shorter version on the YouTube channel.\n\n\n\n\nInstrumentation Tutorial - Signal Generator\nDuration: 2:25",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Laboratory Instruments</span>"
    ]
  },
  {
    "objectID": "lab_intro/lab_safety.html",
    "href": "lab_intro/lab_safety.html",
    "title": "Laboratory Safety",
    "section": "",
    "text": "The Faculty of Science of Engineering has a safety document which can be viewed online. The following points are of relevance to the Electronics Laboratory:\n\nThe fire exits are through the main entrance or the connecting door to the adjacent Sports Science laboratory. If the fire alarm sounds, go downstairs to the covered walkway and out of the building by the shortest route. Do not use the lifts. The congregation point is on the seaward side of the building, near the south-eastern corner (Margam Square).\nCoats and bags MUST be kept in the area provided in the laboratory. Any item left on the floor or around the benches constitutes a trip hazard.\nGreat care has been taken to prevent electric shock by keeping all voltage sources above 48V away from careless fingers. Do not remove any covers on instruments or experiment hardware.\nYou will need to use hand tools and soldering irons from time to time. Take great care to use personal protective equipment, soldering iron stands, and heatproof mats as appropriate.\nReport any accident as soon as possible to one of the demonstrators or technical staff.\n\n\n\n\nCopyright © 2021-2024 Swansea University. All rights reserved.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Laboratory Safety</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html",
    "href": "lab_intro/experiment0.html",
    "title": "Experiment: to construct an oscillator",
    "section": "",
    "text": "Plug-In Breadboard\nIf you place the plug-in breadboard under an X-ray machine, you will see the metal springs inside the plastic cover laid out, as seen in Figure 15.1 above. The long horizontal tracks are used for power supply connections, and the short vertical tracks are used for the interconnection of resistors, capacitors and transistors. The plug-in breadboard is very useful for trying out experimental circuits. Components can be plugged in and interconnected with minimal fuss and without soldering. Changing a component for one of a different value takes only a matter of seconds, and after the experiment, all the parts can be recovered intact for future experiments.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#plug-in-breadboard",
    "href": "lab_intro/experiment0.html#plug-in-breadboard",
    "title": "Experiment: to construct an oscillator",
    "section": "",
    "text": "Figure 15.1: X-ray view of the plug-in breadboard.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#circuit-diagram",
    "href": "lab_intro/experiment0.html#circuit-diagram",
    "title": "Experiment: to construct an oscillator",
    "section": "Circuit Diagram",
    "text": "Circuit Diagram\n\n\n\n\n\n\nFigure 15.2: Circuit diagram of an oscillator.\n\n\n\nReferring to the circuit in Figure 15.2 above, there are only eight electronic components arranged symmetrically. The circuit symbols bear no resemblance to their practical components – for example, the transistors are black plastic D-shapes with three wires emerging from one end, and the capacitors are little blue or yellow discs. The theoretical circuit must be translated into a practical layout on the plug-in breadboard, taking into account the physical size of the components and their connections. A recommended layout is given in Figure 15.3 below. There are six wire links – four on the breadboard and two between the breadboard and the red and black terminals. These can be cut from single-strand insulated wire.\n\n\n\n\n\n\n\nFigure 15.3: Suggested Layout on Plug-in Breadboard.\n\n\n\nResistors can be identified by their coloured bands, but to give confidence using the Rohde & Schwarz multimeter. Switch the instrument on, and press the button labelled “Ω”. Connect a red flexible lead to the red socket labelled “VΩ” and a black flexible lead to the black socket labelled “COM”. Touch the plug ends to the component leads and read off the value on the display.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#sec-5.3",
    "href": "lab_intro/experiment0.html#sec-5.3",
    "title": "Experiment: to construct an oscillator",
    "section": "Introducing – The Rohde & Schwarz HMC 8043 Triple-Output Power Supply",
    "text": "Introducing – The Rohde & Schwarz HMC 8043 Triple-Output Power Supply\n\n\n\n\n\n\nFigure 15.4: Rohde & Schwartz HMC 8043 Triple-Output Power Supply\n\n\n\nEach workstation in the laboratory is equipped with two power supplies, the Rohde & Schwarz HMC 8043 and the Rohde & Schwarz HMC 8042. The HMC 8042 is similar to the HMC 8043, but it only has two outputs. For our laboratory introduction, either power supply can be used as only one output is necessary.\nThe three power supply outputs are independent, so they can be connected in series if necessary to make a “split supply”. We shall use this feature in the second-semester laboratory, EG-152. For this first experiment, only one output, CH1, will be used to power our test circuit.\nThe buttons on the top row, labelled CH1, CH2 and CH3, determine which power supplies are selected for setting voltage and current limit. The second row of buttons labelled CH1 ON/OFF, and so on are used to isolate individual outputs. Finally, there is a button labelled MASTER ON/OFF, which disconnects all power supply outputs from the red and blue terminals.\nIn Figure 15.4 above, the HMC 8043 only has one output selected, CH1 (you can see that the button is illuminated). On the display, CH1 is highlighted, and the cursor is positioned to allow the terminal voltage to be adjusted using the navigation buttons and wheel on the right of the power supply.\n\nThe right-hand field of the display has two functions. Until MASTER ON/OFF is selected, the current shown is the maximum allowable, also known as the current limit. When the MASTER ON/OFF is illuminated, the current shown will be the actual value delivered to the external circuit, up to the current limit.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#setting-up-the-power-supply",
    "href": "lab_intro/experiment0.html#setting-up-the-power-supply",
    "title": "Experiment: to construct an oscillator",
    "section": "Setting up the power supply",
    "text": "Setting up the power supply\nNext the power supply must be set up. As mentioned in Introducing – The Rohde & Schwarz HMC 8043 Triple-Output Power Supply, each workstation in the laboratory is equipped with a Rohde & Schwarz HMC 8043 triple output power supply. Each channel can be adjusted from zero to 32 volts, with a maximum current of 3 amps. The Channel 1 output is used for this part of the experiment. The other outputs are identical to Channel 1 in capability but are not used for this experiment.\n\nTurn the power supply ON by pressing the button in the lower-left corner of the front panel.\nThe display shows the settings for all three outputs, with voltage on the left and current on the right. The current shown is the maximum available from that channel.\nPress the button CH1; a soft menu appears.\nPress the soft key labelled Voltage; the voltage for channel 1 can be varied using the up/down arrows on the navigation control or by turning the rotary control. Individual digits can be selected using the left/right arrows on the navigation control.\nAdjust the voltage to read 3V on the display, then press the rotary control to confirm.\nPress the button CH1; a soft menu appears.\nPress the soft key labelled Current; the maximum current (also known as current limit) can be varied using the up/down arrows on the navigation control or by turning the rotary control. Individual digits can be selected using the left/right arrows on the navigation control.\nAdjust the maximum current to read 0.1A on the display, then press the rotary control to confirm.\nPress the button CH1 ON/OFF; although it is illuminated, the output is still not active.\nPress the button Master ON/OFF; now the channel 1 output is active, and the current display shows the ACTUAL current flowing, rather than the maximum available.\nPress the button Master ON/OFF again, to isolate the output until it is needed.\nCongratulations! You have set up the power supply for the experiment.\n\nConnect the power supply to the breadboard using flexible leads with 4mm plugs at each end, observing the colour convention red = +3V, black = 0V.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#sec-lab-intro-rns-socilloscope",
    "href": "lab_intro/experiment0.html#sec-lab-intro-rns-socilloscope",
    "title": "Experiment: to construct an oscillator",
    "section": "Introducing the Rohde & Schwarz RTM2024 Real-Time Digital Oscilloscope",
    "text": "Introducing the Rohde & Schwarz RTM2024 Real-Time Digital Oscilloscope\n\n\n\n\n\n\nFigure 15.5: A Rohde & Schwarz RTM2024 Real-Time Digital Oscilloscope\n\n\n\nAn oscilloscope is an essential instrument for Electronic Engineers. It provides a “window” into the circuit, showing the changing voltages as a function of time. Our standard laboratory oscilloscope is one of a series produced by Rohde & Schwarz, and, in reality, far exceeds in its specification what we need for our modest experiments. Former students often tell us that the instruments in their place of work are not as sophisticated as the ones we use every day!\nRefer to the photograph shown in Figure 15.5 and note the following groups of controls.\n\nThe VERTICAL group of controls selects which channels are active (currently on-screen) and allows us to move the selected trace up and down. The illuminated buttons show which channel is selected.\nThe SCALE control adjusts the vertical sensitivity, normally expressed in Volts per division. The POSITION control allows us to move the selected trace up and down so that it fits into the screen area. Measurements on the vertical axis can be achieved by the simple expedient of counting squares, or, more precisely, using the cursors as described later in this document.\nThe HORIZONTAL group of controls determines the time axis of the display. Increasing or decreasing the horizontal SCALE causes the trace to expand or contract so that one or more cycles of the waveform under examination are visible on the display. The POSITION control allows us to move the trace left and right on the display.\nThe two other major groups of controls, NAVIGATION and TRIGGER, will be dealt with later when we start to take some real measurements.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#sec-lab-intro-setup-oscilloscope",
    "href": "lab_intro/experiment0.html#sec-lab-intro-setup-oscilloscope",
    "title": "Experiment: to construct an oscillator",
    "section": "Setting up the Oscilloscope",
    "text": "Setting up the Oscilloscope\nEach workstation in the laboratory is equipped with a Rohde & Schwarz RTM 2024 digital oscilloscope. This is a sophisticated instrument with many features. In this experiment we shall use two of its four input channels to view waveforms in our practical circuit.\n\nTurn the instrument on by pressing the button POWER in the lower left corner.\nTo set up the vertical input CH1, press the button labelled CH1. The vertical controls will light up yellow to indicate that they are in control of channel\nRotate SCALE until the indicator at the top of the screen shows CH1: 1V; each vertical unit as defined by the grid lines now represents one volt.\nTo set up the vertical input CH2, press the button labelled CH2. The vertical controls will light up green to indicate that they are in control of channel 2.\nRotate SCALE until the indicator at the top of the screen shows CH2: 1V; each vertical unit as defined by the grid lines now represents one volt.\nTo set up the time base, refer to the controls in the box marked HORIZONTAL. Rotate the control marked SCALE until the indicator at the top left corner of the screen reads TB: 50µs. Every horizontal unit now represents a time interval of 50µs.\nPress CH1 and adjust POSITION until the yellow trace is in the top half of the screen.\nPress CH2 and adjust POSITION until the green trace is in the lower half of the screen.\nLook to the right of the controls. Press SOURCE followed by the soft key (below the screen) to select channel one as the trigger source for the time base.&lt;\nConnect the probe for channel 1 to TP1 (the collector of one transistor).\nConnect the probe for channel 2 to TP4 (the collector of the other transistor).\nConnect both earth clips to suitable points on the plug-in breadboard track connected to zero volts.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#sec-lab-intro-screen-capture",
    "href": "lab_intro/experiment0.html#sec-lab-intro-screen-capture",
    "title": "Experiment: to construct an oscillator",
    "section": "Oscilloscope screen capture",
    "text": "Oscilloscope screen capture\nThere are several ways of saving pictures captured on the oscilloscope screen. The simplest is to plug a USB memory stick into the front panel socket and press the button PRINT. The screen image will be saved onto the memory stick with automatic numbering. The size of the file depends on the mode selected. The typical size of a file type PNG is 30 kbyte, and the typical size of a file type BMP is 2.4 Mbyte.\nThe oscilloscope is connected to the PC using Ethernet. A utility is available to copy the oscilloscope screen directly into an open WORD document. e.g. your lab diary, using the “Add-ins” tab.\nThe oscilloscope can be accessed from a web browser by typing in the URL 192.168.29.2. The pages which appear allow the oscilloscope to be remote controlled and to capture the screen.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#testing-the-circuit",
    "href": "lab_intro/experiment0.html#testing-the-circuit",
    "title": "Experiment: to construct an oscillator",
    "section": "Testing the circuit",
    "text": "Testing the circuit\nBefore turning the supply on to your oscillator ask one of the demonstrators to check that everything is correct. Then press the power supply button MASTER ON/OFF and, if all is well, two square waves should appear on the oscilloscope screen. Adjust the vertical position controls and vertical span controls if necessary to give a display like the example, Figure 15.7, shown in this document.\nWhen the traces are displayed to your satisfaction, the next step is to superimpose cursors to make time and voltage measurements of the waveforms.\n\nPress the button labelled CURSOR.\nPress the soft key labelled Measurement Type and select Voltage & Time from the drop-down menu.\nPress the soft key labelled Source and select CH1 from the drop-down menu.\nThere should be two horizontal cursors and two vertical cursors on screen, labelled 1 to 4.\nRotate NAVIGATION until cursor 1 is at the start of a cycle. Press NAVIGATION.\nRotate NAVIGATION until cursor 2 is at the end of the same cycle. Press NAVIGATION.\nRotate NAVIGATION until cursor 3 is at the top of the yellow trace. Press NAVIGATION.\nRotate NAVIGATION until cursor 4 is at the bottom of the yellow trace. Press NAVIGATION.\nRead off the period of the square wave and its amplitude from the on-screen display. The difference between C1 and C2 appears as \\(\\Delta t\\) and the difference between C3 and C4 appears as \\(\\Delta V\\).\n\nRecord \\(\\Delta t\\) and \\(\\Delta V\\) as text in your lab diary. The oscilloscope traces can be saved in your lab diary document using one of the methods outlined in Oscilloscope screen capture. Use this procedure to record the waveforms at test points TP1 and TP4. Make sure that the maximum amount of information is on the screen, including vertical and horizontal cursors and voltage and time readings along the lower edge of the screen.\nNext, move the oscilloscope probe on TP4 to TP2. Now, instead of two square waves, the oscilloscope will display a square wave and a complex waveform showing the charging of one of the capacitors. Again, use the cursors to measure times and voltages and record them as text in your lab diary. Copy the screen to the PC and paste it into the lab diary\nNow try varying the supply voltage. On the Rohde & Schwarz power supply, press the soft key Voltage so that the voltage field is selected, then carefully turn the navigation control to reduce the supply to 1.5V. If necessary, adjust the vertical scale of the oscilloscope channels to enlarge the traces. Use the horizontal cursors to measure and record the period (and hence frequency) of the square wave. Repeat the measurements for TP1 and TP2 and TP3 and TP4 and copy the screens to the PC and your lab diary as before.\nFinally, turn on all four input channels of the Rohde & Schwarz oscilloscope, and connect them to TP1, TP2, TP3, TP4 respectively. Copy the screen to your lab diary.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#laboratory-diary",
    "href": "lab_intro/experiment0.html#laboratory-diary",
    "title": "Experiment: to construct an oscillator",
    "section": "Laboratory Diary",
    "text": "Laboratory Diary\nAll experiments must be recorded in your lab diary (a Word document) for assessment. It is particularly important to record your observations at the time, rather than scribble them down on a random piece of paper and write them up later. You must not accumulate a backlog of incomplete experiments, so it is vital to make clear, concise notes on the spot. The objective is not to produce an impeccable lab diary but to have a clear record which could form the basis of a formal laboratory report later.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#assessment",
    "href": "lab_intro/experiment0.html#assessment",
    "title": "Experiment: to construct an oscillator",
    "section": "Assessment",
    "text": "Assessment\nThe assessment of this laboratory introduction will be as follows:\n\nInspection of the lab diary. You must submit a copy of your lab diary containing screenshots of the waveforms from the oscillator circuit and from the simulation exercise that follows, with appropriate observations of voltage, time and frequency. The lab diary should also contain the answers to the questions posed in Questions which you will enter into your lab diaries and also into a Canvas Quiz for grading. A mark will be awarded out of five for the lab diary and five for the answers to the questions. You will also be given formative feedback on the structure of the lab diary so that you can address any presentation issues before the submission of a complete lab diary at the end of the module.\nInspection of the continuity tester. The technician in charge will mark the construction exercise out of 5. Marks will be taken off for poor soldering and untidy component placement. It is your responsibility to make sure that the technician in charge sees your work.\n\nThe total mark available for the laboratory introduction is 15. To put this into perspective, a typical exam question is worth about 25 marks.\nThe remaining 85 marks in EG-151 are carried by the formal assessment of the microcontrollers laboratory, the project and the class test.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/experiment0.html#example-circuits-and-ocilloscope-traces",
    "href": "lab_intro/experiment0.html#example-circuits-and-ocilloscope-traces",
    "title": "Experiment: to construct an oscillator",
    "section": "Example circuits and ocilloscope traces",
    "text": "Example circuits and ocilloscope traces\nThese images are produced for guidance. They must not be copied and included in your lab diary! Gnenerate your own versions.\n\n\n\n\n\n\nFigure 15.6: A photograph of the completed oscillator circuit as prototyped on breadboard.\n\n\n\n\n\n\n\n\n\nFigure 15.7: Waveforms on Rohde & Schwarz Oscilloscope at test points 1 and 4.\n\n\n\n\n\n\n\n\n\nFigure 15.8: Waveforms on Rohde & Schwarz Oscilloscope at test points 1 and 2.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Experiment: to construct an oscillator</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html",
    "href": "lab_intro/simulation.html",
    "title": "Simulation Exercise",
    "section": "",
    "text": "Use of Multisim\nStarting from the Windows desktop, click on “Zenworks” followed by “Engineering” and select NI Multisim 14.2 from the list of available packages. The main screen should look like Figure 16.1:\nIf there is a wide dialogue box at the bottom of the screen, click on “View” and untick the item “Spreadsheet view”. The dialogue box should disappear.\nWe shall now use Multisim to create a simulated circuit and oscilloscope, that is identical in function to the oscillator built on breadboard in section 4.\nThe toolbar of the Multisim program looks like Figure 16.2:\nThe actual appearance may differ depending on the screen resolution and the available options.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#use-of-multisim",
    "href": "lab_intro/simulation.html#use-of-multisim",
    "title": "Simulation Exercise",
    "section": "",
    "text": "Figure 16.1: The National Instruments Multisim home\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16.2: The toolbar of the Multisim programme",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#selection-of-components",
    "href": "lab_intro/simulation.html#selection-of-components",
    "title": "Simulation Exercise",
    "section": "Selection of Components",
    "text": "Selection of Components\n\nClick on the “Ground” A dialogue box “Select a component” appears.\nSelect “Power Source” from the left-hand Click on “DC Power” in the right-hand column, followed by “OK”. The dialogue box disappears, and a battery symbol appears. Move the symbol to the desired location. When the symbol has been placed (left click), the dialogue box reappears.\nClick on “Ground” on the right-hand Click on “OK”, and the dialogue box disappears. Place the ground symbol in the desired location. The dialogue box reappears.\nClick “OK” and place another ground symbol on the Repeat until there are five in total.\nDismiss the “Select a Component” dialogue by clicking on “Close”.\n\nThe battery voltage must be changed to 3V. Place the cursor exactly in the middle of the battery and right-click. A dialogue box appears. Select “Properties” and change the value to 3V.\n\nClick on the “Resistors” A dialogue box “Select a Component” appears.\nClick on “Resistor” on the left-hand column.\nScroll the right-hand column until the value “1k” Click on “OK”.\nPlace four resistors using the same procedure as for the ground\nClick on “Capacitor” in the left-hand column.\nScroll the right-hand column until the value “10nF” Click on “OK”.\nPlace three capacitors using the same procedure as for the ground symbols and resistors.\nDismiss the “Select a Component” dialogue by clicking on “Close”.\n\nThe resistors are all oriented in a horizontal position. We need to turn them through 90 degrees and change the value of two of them to 15k. Begin by placing the cursor exactly in the middle of a resistor. Right-click to reveal a dialogue box. Select “Rotate 90 deg clockwise”. Repeat this for all four resistors. To change the value of a resistor, right-click on the resistor, select “Properties”, and change the value to 15k. All four resistors should now be vertical, with two valued 1k and two valued 15k.\nUse the same procedure to change the value of ONE capacitor to 10pF. Next, we shall select and place two transistors.\n\nClick on the “Transistors” A dialogue box “Select a Component” appears.\nClick on “BJT NPN” in the left-hand column.\nScroll the right-hand column until the value “BC547BP” Click on “OK”.\nPlace two transistors using the same procedure as for the ground symbols and\nDismiss the “Select a Component” dialogue by clicking on “Close”.\n\nBoth transistors are “facing left”. We want them to face each other, so one must be flipped in the horizontal direction. Begin by placing the cursor exactly in the middle of a transistor. Right-click to reveal a dialogue box. Select “Flip Horizontally”.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#wiring-the-circuit",
    "href": "lab_intro/simulation.html#wiring-the-circuit",
    "title": "Simulation Exercise",
    "section": "Wiring the circuit",
    "text": "Wiring the circuit\nComponents can be repositioned by placing the cursor exactly in the middle of the component and holding down the left mouse button as the component is moved; when the component is in the correct position, then release the left mouse button (“drag and drop”).\nWhen the components are arranged to your satisfaction, wire them up according to Figure 16.3 below. Place the cursor at the end of a component, and when the “blob” appears, drag a wire to the next component and release the mouse button. If you drag a connection to the middle of an existing wire and left click, a new “blob” appears. Wires can be re-positioned by placing the cursor on the wire and dragging it in the required direction.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#connecting-the-oscilloscope",
    "href": "lab_intro/simulation.html#connecting-the-oscilloscope",
    "title": "Simulation Exercise",
    "section": "Connecting the Oscilloscope",
    "text": "Connecting the Oscilloscope\nWe need some means of observing the operation of the circuit. Run the cursor down the list of icons on the right-hand side of the screen. Find the oscilloscope. Click to select, and the oscilloscope icon appears on the screen. Drag the oscilloscope icon to the desired position. This icon is just for connecting to the rest of the circuit; the “real thing” is revealed when the icon is double-clicked.\nNote that the oscilloscope icon has pairs of connections to each of its “y” channel inputs A and B. Begin by connecting the “ground” side of each input to a ground symbol. Both grounds can go to the same ground symbol. Connect one of the “y” inputs to TP1 and the other to TP2. Now double-click the oscilloscope icon to reveal the instrument's front panel. Use the up and down arrows in the Channel A, Channel B and Timebase “Scale” boxes to set the vertical sensitivity to 2V per division and the timebase to 0.05ms per division. The simulation circuit is now ready to run.\n\n\n\n\n\n\nFigure 16.3: The completed circuit being simulated in Multisim with the oscilloscope trace visible.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#running-the-simulation",
    "href": "lab_intro/simulation.html#running-the-simulation",
    "title": "Simulation Exercise",
    "section": "Running the simulation",
    "text": "Running the simulation\nThe circuit can now be turned on using the green triangle in the command line. A waveform should appear on the screen. Use “Y-pos” to move Channel B down the screen so that it is separate from Channel A. Click the button marked “pause/resume” to give a stationary display with 2 or 3 cycles visible. Here are some hints for running the simulation:\n\nClick on “reverse” to give a white background instead of a black one. This saves ink if you print out the simulation and looks neater.\nSometimes, there is an error message when the simulation is started. Try changing the following setting: Simulate/Interactive, then select “Initial Condition - Set to Zero”. Select “Max time step” and alter the value to 1e-006. Click on OK.\nWhen you are preparing a screen to be saved, click on the Trigger setting “Single” instead of “Auto”. Now every time you click the “Pause” button (alongside the green triangle), a full screen will appear on the oscilloscope display.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/simulation.html#making-measurements",
    "href": "lab_intro/simulation.html#making-measurements",
    "title": "Simulation Exercise",
    "section": "Making Measurements",
    "text": "Making Measurements\nThe practical oscilloscope has X and Y cursors so that readings of time and voltage can be made from the display. The simulated oscilloscope is slightly different. It has X cursors only; however, the oscilloscope reports time and voltage for each X cursor, so the same information is available. The only omission is a \\(1/t\\) or frequency readout - you must calculate it yourself!\nLook at the top left of the simulated oscilloscope display. There are two coloured triangles which can be dragged across the display. Position one cursor at the start of a cycle and the other cursor at the start of the next cycle. The period of the waveform can be read from the “T2-T1” box.\nRecord the values measured for the period and calculate the frequencies (be careful to use sensible units) in your lab diary.\nScreengrab the simulation display and copy it into your lab diary: \n\nSelect “Tools - Capture Screen Area”. A dotted box appears on the computer\nExpand the dotted box and move it to enclose the part of the screen you want to save. Click on the icon found at the top left of the dotted box. The selected area has now been copied to the\nBring up WORD and paste the simulation image into your lab diary.\n\nStop the simulation by pressing the pause icon on the command line. Move Channel B's oscilloscope input from TP1 to TP3, then run the simulation and copy the new screen image to your lab diary. Use the cursors to measure and record the amplitude, period and frequency of the waveforms.\nFinally, change the property of the battery from 3V to 1.5V and repeat the above measurements. You will need to change the oscilloscope settings, Channel A Scale and Y-Pos, Channel B Scale and Y- Pos; otherwise, the waveforms will be too small in the vertical direction.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Simulation Exercise</span>"
    ]
  },
  {
    "objectID": "lab_intro/questions.html",
    "href": "lab_intro/questions.html",
    "title": "Questions",
    "section": "",
    "text": "Question 1",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Questions</span>"
    ]
  },
  {
    "objectID": "lab_intro/questions.html#question-1",
    "href": "lab_intro/questions.html#question-1",
    "title": "Questions",
    "section": "",
    "text": "For the prototype circuit that you build on the breadboard what is the frequency of oscillation of the breadboard circuit:\n\n\nwith the power supply set to 3V;\nwith the power supply set to 1.5V?",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Questions</span>"
    ]
  },
  {
    "objectID": "lab_intro/questions.html#question-2",
    "href": "lab_intro/questions.html#question-2",
    "title": "Questions",
    "section": "Question 2",
    "text": "Question 2\nFor the simulated circuit what is the frequency of oscillation of the simulation circuit: 1. with the power supply set to 3V; 2. with the power supply set to 1.5V? (hint: frequency is the reciprocal of period).",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Questions</span>"
    ]
  },
  {
    "objectID": "lab_intro/questions.html#question-3",
    "href": "lab_intro/questions.html#question-3",
    "title": "Questions",
    "section": "Question 3",
    "text": "Question 3\nAn earlier version of the simulation software had a problem when power was switched on.\nThe circuit would not start oscillating, because in the simulated circuit both base resistors were identical, the capacitors were identical and so were the transistors. An “extra capacitor” of 10 pF was added to introduce a slight imbalance in the circuit which is otherwise perfectly symmetrical.\n\nWhat fraction of the 10 nF capacitor is the “extra capacitor”?\nDo you think it has a significant effect on the frequency of oscillation?\nWhy is the “extra capacitor” not needed for the practical circuit? (Hint: think about the difference between practical components and simulated components).",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Questions</span>"
    ]
  },
  {
    "objectID": "lab_intro/questions.html#question-4",
    "href": "lab_intro/questions.html#question-4",
    "title": "Questions",
    "section": "Question 4",
    "text": "Question 4\nAny simulation software must be verified by comparison with the equivalent practical circuit. Are you confident that Multisim 14.2 produces results consistent with “the real thing”? Justify your answer.\nNow transfer your answers into the quiz that you will find on Canvas.\nEach lab partner should make their own submission.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Questions</span>"
    ]
  },
  {
    "objectID": "lab_intro/construction.html",
    "href": "lab_intro/construction.html",
    "title": "Construction Exercise - Continuity Tester",
    "section": "",
    "text": "What is a Continuity Tester?\nA continuity tester is an essential tool for the electrical engineer. It allows the user to follow wires, printed circuit tracks, and ribbon cables from one end to the other with ease. Bulbs, fuses, motor windings, and transformers, can be tested for continuity. Diode polarity and transistor gain can also be determined with little care. These tests can, of course, be performed using a multimeter, but an audible indication is particularly useful because it is not necessary to look away from the circuit under examination.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Construction Exercise - Continuity Tester</span>"
    ]
  },
  {
    "objectID": "lab_intro/construction.html#circuit-operation",
    "href": "lab_intro/construction.html#circuit-operation",
    "title": "Construction Exercise - Continuity Tester",
    "section": "Circuit Operation",
    "text": "Circuit Operation\nThe simplest form of continuity tester is a torch bulb and battery. This can be used to test circuits of low resistance, but for electronic circuits, a low applied voltage and test current is much more suitable. Our tester uses a circuit attributed to a Mr Eccles and a Mr Jordan (see Figure 18.1) and is referred to in textbooks as an “astable multivibrator”. An astable multivibrator consists of two transistors, cross-coupled using resistors and capacitors, which oscillate at a well-defined frequency. The two transistors are switching in antiphase; that is, one is on, and the other is off at any given instant. A loudspeaker connected between the collectors will experience a peak-to-peak voltage of twice the supply, so a low voltage battery can be used and still produce a loud noise. The base resistors and the capacitors control the pitch (frequency) of the sound.\n\n\n\n\n\n\nFigure 18.1: Circuit Diagram of Continuity Tester",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Construction Exercise - Continuity Tester</span>"
    ]
  },
  {
    "objectID": "lab_intro/construction.html#circuit-construction",
    "href": "lab_intro/construction.html#circuit-construction",
    "title": "Construction Exercise - Continuity Tester",
    "section": "Circuit Construction",
    "text": "Circuit Construction\nThe circuit is symmetrical and suited to construction on stripboard (Veroboard). Stripboard consists of an insulating board with thin copper tracks spaced 0.1 inches apart and perforated with holes on a 0.1-inch grid. Before any soldering, certain tracks must be cut using a special tool. This is a drill bit in a handle and must be used lightly to avoid damaging the board. It is centred on a hole and twisted a half turn so that a thin sliver of copper is removed. Then the cut must be inspected to ensure no “whiskers” of copper remain.\nOrient the board as seen in Figure 6.2, looking at the component side. The first component to be mounted is the left-hand 1k resistor. Its leads are bent (using pliers, not by hand!) so that the spacing is 0.4 inches. Then it is fitted onto the board, as shown in {ref}fig8.2, and the leads are bent out slightly so that it does not fall out when the board is inverted. The lead indicated must be bent at right angles so that it lies across the tracks to form a bridge. Bend and insert the right-hand 1k resistor and bend the top lead to form a bridge to the last track. The two 15k resistors are mounted on the board as shown, but their leads will be cut short after soldering. Now the leads can be soldered so that the bent lead bridges the top end of all four resistors. After soldering, cut the remaining resistor leads flush with the board.\n\n\n\n\n\n\nFigure 18.2: Construction on Stripboard\n\n\n\nRefer to {ref}soldering for instructions on soldering. If you have never used a soldering iron previously, ask one of the demonstrators for help. Make sure you work on one of the extraction mats with the air filter turned on to keep the fumes away from your face.\nIdentify the two 10nF capacitors. Their leads are deformed to a spacing of 0.2 inches; straighten and re-bend the leads to a spacing of 0.3 inches. Then fit the capacitors as shown and solder them in place. Trim the leads flush with the board.\nNext, unpack the two BC547 transistors. Unlike the resistors and capacitors, these components are polarity sensitive and must be wired correctly. Refer to the diagram for the proper orientation. The transistors on the prototype were fitted so that the emitter leads occupied just one hole on the centre strip; if you wish, the transistors can be mounted separately, with the left-hand component dropped down towards the speaker by one hole. Before fitting the transistors, slightly spread the leads, so they are spaced 0.1 inches. Solder and trim the leads and avoid over-heating the transistors when you solder them in place.\nThe piezoelectric loudspeaker is fitted flush to the board, then soldered in place and the leads trimmed. Try to avoid over-heating, or else the plastic body will melt. Cut the leads carefully, as they are liable to fly off at high speed.\nThe power source for our circuit is an N-type alkaline cell. Alkaline batteries are more expensive than zinc-carbon, but they last a long time. A battery holder is provided: prepare it by bending the leads through 90 degrees at a spacing of 2.5mm from the plastic body. Solder the battery holder in place and trim the leads. Caution! The leads are made of hard metal and will fly off when cut. Take care to wear suitable eye protection and, if possible, retain the cut end for safe disposal.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Construction Exercise - Continuity Tester</span>"
    ]
  },
  {
    "objectID": "lab_intro/construction.html#final-assembly",
    "href": "lab_intro/construction.html#final-assembly",
    "title": "Construction Exercise - Continuity Tester",
    "section": "Final Assembly",
    "text": "Final Assembly\nThe circuit board must be protected from short-circuits and mechanical damage. The appropriate case for the continuity tester is a Tic-Tac® box. Remove the adhesive label, then drill a 3mm hole in the middle of the square of white plastic on the lid - NOT through the little door. An alternative to a 3mm drill is the stripboard cutting tool. Prepare the test leads by soldering a crocodile clip on one end of each lead - ask for help from one of the demonstrators if you are unsure how to do this. Take great care if you solder the clips yourself; they will retain heat for a minute or so after soldering and can burn an unwary finger. The plastic covers on the crocodile clips should not be fitted until the metal has cooled. Don’t forget to fold over the cable grip tabs using pliers.\nThread the red and black flexible leads through the hole in the lid, and strip back about 2mm of insulation on the open ends. Tin the bare ends so that they are wetted with solder. Tie a single knot in both wires near the end as a precaution against pulling. Tin two areas of the copper strip at the bottom of the board, as shown in the diagram. Don’t try and thread the bare ends through holes in the board; they are too big. Lay them flat directly on the copper side and solder them in place. Slide the whole assembly into place in the Tic-Tac® box and adjust the position of the knot if necessary.\nWhen the board is fitted into its case, make a small mark on the plastic corresponding to the hole in the Piezo loudspeaker. Remove the board and cut a 3mm hole on the mark. Refit the board - the hole should line up with the centre of the loudspeaker. This is to allow the sound to be heard clearly.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Construction Exercise - Continuity Tester</span>"
    ]
  },
  {
    "objectID": "lab_intro/construction.html#testing",
    "href": "lab_intro/construction.html#testing",
    "title": "Construction Exercise - Continuity Tester",
    "section": "Testing",
    "text": "Testing\nThe only test required is to touch the metal ends of the test clips together. If a high-pitched tone is heard, then congratulations! You have built a useful instrument and demonstrated your dexterity. If by chance, the circuit does not function, ask one of the demonstrators to help identify the problem. Try testing a silicon diode; the tester should sound only if the black lead is clipped to the banded end of the diode. Try clipping the tester across resistors of 100 Ohms and 1k Ohms; they will produce a fainter tone because the external resistance reduces the test current. Finally, borrow an NPN transistor and connect the red lead to the collector and the black lead to the emitter. Touch a 10k resistor between the base and collector leads; the tone should be heard. This shows that the transistor is amplifying the tiny current flowing through the base and allowing enough current to pass between collector and emitter to power our continuity tester.\nWhen the tester is not in use, it is recommended that you attach the clips to a small piece of card so that they cannot accidentally touch and run the battery down. Anticipated battery life is 1000 hours of continuous operation and five years of intermittent use.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Construction Exercise - Continuity Tester</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html",
    "href": "lab_intro/soldering.html",
    "title": "Safe Soldering",
    "section": "",
    "text": "About soldering\nThe electronics industry relies on soldered joints, from the finest track on a microchip all the way up to massive conductors in the power distribution network. Soldering is so important to the electronics industry; it is specified as an essential skill in the IET requirements for professional engineers! You may not be called upon to use this skill very often in your career, but you must learn how to make reliable soldered joints without damage to the components and to be aware of the hazards.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#soldered-joints",
    "href": "lab_intro/soldering.html#soldered-joints",
    "title": "Safe Soldering",
    "section": "Soldered joints",
    "text": "Soldered joints\nSolder is not some kind of metallic glue; it forms an intimate (eutectic) bond with the two pieces of metal to be joined. You will see that molten solder flows like water over the surfaces to be joined, leaving a thin film behind when cool which cannot be removed without abrading the surface.\nThe most commonly used form of solder is a mixture of lead and tin. A plumber might use a solder with a high proportion of lead. However, the solder used until recently in the electronics industry is a 60:40 alloy of the two metals. The electronics industry has switched over to lead-free solder, which is mostly tin with a small percentage of copper and silver. This change has been driven by concerns about the fumes from molten lead, which have been related to several medical conditions. Lead-free solder has a higher melting point than lead/tin solder, typically 340 Celsius as opposed to 300 Celsius for the older lead alloys. This means that the tools used must be capable of resisting higher temperatures and that the components are at greater risk during the soldering process. A more aggressive flux is used in lead-free solder to improve the ability of the solder to “wet” the joint.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#tools-for-soldering",
    "href": "lab_intro/soldering.html#tools-for-soldering",
    "title": "Safe Soldering",
    "section": "Tools for soldering",
    "text": "Tools for soldering\nThe electronics industry uses techniques such as infra-red and wave soldering in the mass production of electronic circuits. In the laboratory, we are content to make soldered joints one at a time using a soldering iron. This is essentially a metal stick heated with an electric element, having a shaped tip to make contact with fine electrical connections. Our laboratory is equipped with low-voltage, temperature-controlled soldering irons which operate on a 24 V supply so that there is no mains voltage present in the iron. A transformer in the safety stand reduces the mains voltage to 24 V and provides electrical isolation. A temperature sensor embedded in the iron is used to provide feedback to an electronic circuit in the stand so that the desired temperature can be set using a control.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#preparations-for-soldering",
    "href": "lab_intro/soldering.html#preparations-for-soldering",
    "title": "Safe Soldering",
    "section": "Preparations for soldering",
    "text": "Preparations for soldering\nIf the circuit board is bare copper, it must be bright and shiny before it will take solder. If it is tinned - coated with a thin layer of solder - this must be clean and free from contamination. Similarly, component leads must be bright and clean.\nThe soldering iron must be at the correct temperature (typically 300 Celsius for lead/tin solder), and the tip of the iron must be wiped clean on a wet cellulose sponge and then tinned with a small amount of solder. If necessary, clean the tip on the sponge again and re-tin it with new solder. The solder used in the laboratory has a core of resin flux, which evaporates when heat is applied, helping the solder to wet the joint. Old solder, e.g. droplets which have solidified after cleaning the tip, contains no flux and will form poor-quality joints.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#making-a-soldered-joint",
    "href": "lab_intro/soldering.html#making-a-soldered-joint",
    "title": "Safe Soldering",
    "section": "Making a soldered joint",
    "text": "Making a soldered joint\nLet us consider a component lead threaded through a circuit board. The lead and the copper tracks must be all at a high enough temperature to melt the solder BEFORE the solder is applied. If this is the case, the solder will flow like water over the joint and form a smooth curved surface when it solidifies. If the solder alone is heated, the joint will be “dry” - the solder will sit sullenly on the surface without forming a eutectic bond or forming a blob in mid-air on the component lead. The remedy in such cases is to apply more heat to the joint until the solder runs. If necessary, use a little more solder to provide new flux. In extreme cases, the solder will have to be removed (using braid or a solder pump), and the task starts again.\n\n\n\n\n\n\nFigure 19.1: Soldering a component onto a stripboard.\n\n\n\nReferring to the illustration shown in Figure 19.1:\n\nPlace the tip of soldering iron at the base of the joint to heat both the lead and the track.\nTouch solder to the base of the joint, preferably not on the iron The heat of the wire and track should melt the solder.\nWhen the solder runs like water, take the solder away FIRST.\nTake the iron away from the joint and allow it to cool.\nIf all is well, a smooth curved joint is formed. Trim the wire using side cutters.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#hazards-when-soldering",
    "href": "lab_intro/soldering.html#hazards-when-soldering",
    "title": "Safe Soldering",
    "section": "Hazards when soldering",
    "text": "Hazards when soldering\nThe greatest danger is of burning oneself, either directly or as a result of touching heated metal which has not yet cooled down. A less obvious danger is from spots of molten solder, which might fall on skin or clothing. It is essential to use the safety equipment provided in the laboratory.\n\nAlways return the soldering iron to the safety stand when not in use. NEVER place a soldering iron on the workbench where it will be a danger to yourself and others.\nAlways place the workpiece on one of the heatproof mats, and ensure the extraction nozzle is positioned close by. This will ensure that the fumes are taken away from the workbench.\nUse eye protection in case spots of solder or surplus resin fly away from the It is essential to use safety glasses when cutting component leads since they can fly off at high speed.\nEnsure that the soldering iron does not come into contact with any mains cable, as the high temperature will melt plastic and expose conductors within a few seconds. The tool itself is earthed, so contact with a live wire should result in a blown fuse.\nTreat soldered joints with care, as metal parts can stay hot for several minutes after soldering.\nReport any accident to laboratory staff as soon as possible.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "lab_intro/soldering.html#demonstrations",
    "href": "lab_intro/soldering.html#demonstrations",
    "title": "Safe Soldering",
    "section": "Demonstrations",
    "text": "Demonstrations\nDr Davies has made three videos, accessible on Canvas (Video demonstration: Let’s build a Circuit Continuity Tester from a Tic Tac Box), in which he demonstrates the correct way of preparation and soldering the continuity tester.\nYou may wish to review these videos before performing the construction exercise. There is also a photograph through which Dr Davies has shown the stages in the assembly of his continuity tester. You are invited to check your work against these images.",
    "crumbs": [
      "Laboratory Introduction",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Safe Soldering</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html",
    "href": "labs/get_started/index.html",
    "title": "Getting Started",
    "section": "",
    "text": "Introduction\nMicrocontrollers are an important topic for the Electronics Engineer. So many modern devices have a microcontroller at their core, even apparently “dumb” products such as toasters and electric fans. Specifying the right microcontroller for a specific task is a useful skill, so in our Electronic and Electrical Engineering degree program you will be exposed to a number of different microcontrollers.\nAs an introduction to the subject, we shall learn how to program a popular 8-bit microcontroller in the “C” language. The specific microcontroller we shall be using is the Arduino Nano, a low-cost board with a range of useful features. Before we can program it, however, we shall have to install the Arduino Integrated Development Environment (IDE) onto your computer. If you are using one of the PCs in room B107, the software is already installed. The software is free, so you can install it on your own computer if you wish. The IDE has been produced in several versions, which can be run on Linux, Windows, and Apple computers.\nA vast amount of information about the Arduino project can be found on their website, arduino.cc, including downloads for the IDE. Many of you already have some experience using Arduino harware and software, and so may have the IDE already installed.\nOur friends in the Swansea Hackspace have an extensive web site, which also offers guidance on getting started with Arduino projects. Their website can be found at swansea.hackspace.org.uk. If you click on “Activities” followed by “Learning” you will be offered a range of tutorials, including one on the Arduino. Click on “Introduction to Arduino” and you will find a detailed description of the device. You may find it useful to read through some of these pages before starting on the installation procedure detailed below.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#installing-the-arduino-ide-2-on-your-computer",
    "href": "labs/get_started/index.html#installing-the-arduino-ide-2-on-your-computer",
    "title": "Getting Started",
    "section": "Installing the Arduino IDE 2 on Your Computer",
    "text": "Installing the Arduino IDE 2 on Your Computer\n\nWindows\nModern Windows 10 and 11 machines are capable of finding the necessary driver for the CH340 interface chip automatically. A good strategy would be to start the Windows 10 machine, and when it is ready plug in the Arduino Nano board using the supplied lead. After a few minutes, type Device Manager into the search box, and run the application offered to you. You should see a list of devices, including “Ports (COM and LPT)”. Click on this item and look at the lines following. One of these should read “USB-SERIAL CH340 (COM5)” or similar. Make a note of the COM port number and close the Device Manager.\nNext, unplug the Arduino Nano board. Go to arduino.cc (Figure 20.1) and select the tab “Software&rdquo. This will bring up a new page of options (Figure 20.2). Move past”Arduino Web Editor” and look at the section titled “Downloads” and the box labelled Arduino IDE 2.1.1. Look on the right-hand side and click on “Windows Installer for Windows 10 and newer”, which is the first item in the list. When the installation file has finished downloading return to the previous page using “back” on your browser. In the section marked “Arduino IDE 2.1.1” you will see the words “For more details, please refer to the Arduino IDE 2.0 documentation.” . Click on the link labelled Arduino IDE 2.0 documentation to open the Arduino IDE 2 documentation page (highlighted in Figure 20.3) and then select Downloading and installing the Arduino IDE 2 from the table of contents to open the Downloading and installing the Arduino IDE 2 page (Figure 20.4).\nFollow the detailed instructions for Windows to start the installer. There will follow quite a lengthy installation procedure, during which you will be offered additional drivers for other members of the Arduino family, including the boards offered by the company Adafruit. We recommend installing these additional drivers. When the installation is complete, plug in the Arduino Nano board and click on the “Arduino IDE” icon that has appeared on your desktop.\n\n\n\n\n\n\n\nFigure 20.1: The homepage arduino.cc with software selected\n\n\n\n\n\n\n\n\n\nFigure 20.2: The software page on arduino.cc\n\n\n\n\n\n\n\n\n\nFigure 20.3: The Arduino IDE 2 page\n\n\n\n\n\n\n\n\n\nFigure 20.4: The installation instructions page.\n\n\n\n\n\nLinux\nFortunately, all Linux systems have the necessary drivers in place already, so it is only necessary to install the Arduino IDE application.\nGo to arduino.cc and select the tab “Software”. This will bring up the Arduiono IDE 2 page (Figure 20.2). Move past the instructions for “Arduino Web Editor” and look at the section titled “Downloads”. In the section marked “Arduino IDE 2.1.1” you will see the words “For more details, please refer to the Arduino IDE 2.0 documentation.” . Click on the link labelled Arduino IDE 2.0 documentation to open the Arduino IDE 2 documentation page (highlighted in Figure 20.3`) and then select Downloading and installing the Arduino IDE 2 from the table of contents to open the Downloading and installing the Arduino IDE 2 page (Figure 20.4). Follow the detailed instructions for Linux to start the installer.\nThere will follow quite a lengthy installation procedure, involving unpacking the tar file, and running the script “install.sh”, either from the command line or using “Run in terminal” from “Files”. During the installation you will be offered additional drivers for other members of the Arduino family, including the boards offered by the company Adafruit. We recommend installing these additional drivers. When the installation is complete, plug in the Arduino Nano board and click on the “Arduino IDE” icon that has appeared on your desktop.\n\n\nApple (MacOS)\nOnce again, go to arduino.cc and select the tab “Software”. This will bring up the Arduiono IDE 2 page (Figure 20.2). Move past the instructions for “Arduino Web Editor” and look at the section titled “Downloads”. In the section marked “Arduino IDE 2.1.1” you will see the words “For more details, please refer to the Arduino IDE 2.0 documentation.” . Click on the link labelled Arduino IDE 2.0 documentation to open the Arduino IDE 2 documentation page (highlighted in Figure 20.3`) and then select Downloading and installing the Arduino IDE 2 from the table of contents to open the Downloading and installing the Arduino IDE 2 page (Figure 20.4). Follow the detailed instructions for MacOS to start the installer.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#sec-set-up-arduino",
    "href": "labs/get_started/index.html#sec-set-up-arduino",
    "title": "Getting Started",
    "section": "Initial set up",
    "text": "Initial set up\nWhen you are satisfied that the Arduino IDE has been successfully installed, run the application. Assuming that the installation procedure described above has gone to plan, and after the splash screen, the Arduino IDE main screen (Figure 20.5) appears.\n\n\n\n\n\n\nFigure 20.5: The Ardino IDE 2 Main Screen on First Run\n\n\n\nPlug in the Arduino Nano board (Figure 20.6) using the supplied lead. Next look at the dropdown control labelled Select Board. Identify the connection which depends on your operating system but will be identified as a USB connection on MacOS and Linux, or may be labelled COM 5 (or some other number) on Windows (see Figure 20.7).\n\n\n\n\n\n\nFigure 20.6: The Arduino nano microntroller mounted on breadboard\n\n\n\n\n\n\n\n\n\nFigure 20.7: Choose the port that your nano board is connected on. What you will see here depends on your operating system. I have shown what I see on my MacOS machine.\n\n\n\nOnce you have selected the correct port, you need to identify the board you are using. Search for nano as shown in Figure 20.8.\n\n\n\n\n\n\nFigure 20.8: Search for and select Arduino Nano.\n\n\n\nOnce you have set up your board, the board idenitfier changes to Arduino Nano in the menu bar as shown in Figure 20.9. You are now ready to compile your first program.\n\n\n\n\n\n\nFigure 20.9: Arduino IDE 2 set up and ready to go.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#the-structure-of-an-arduino-program",
    "href": "labs/get_started/index.html#the-structure-of-an-arduino-program",
    "title": "Getting Started",
    "section": "The Structure of an Arduino Program",
    "text": "The Structure of an Arduino Program\nArduino provides a useful program stucture that is called a sketch. The structure of a sketch is illustrated in Figure 20.10.\n\n\n\n\n\n\nFigure 20.10: Flow-chart of an Ardunino sketch program\n\n\n\nAfter the program starts, the setup subprocess (subroutine) is called once, and then the loop subprocess is called over and over again until the processor is restarted or power removed. Note there is no end state for the sketch program.\nIn the setup subprocess, the microcontroller will be set up for the application it is to execute. In the labs to follow, this will be to ensure that the IO is correctly configured.\nIn the loop process, we will set up the activities that will read inputs from the IO and provide suitable outputs. We will provide flow-charts for the examples that follow and you are expectd to provide flow diagrams for any modified programs in your lab diary.\nYou may wish to note that I used PowerPoint flowchart shape library to draw the flowcharts in this document.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#sec-on-the-blink",
    "href": "labs/get_started/index.html#sec-on-the-blink",
    "title": "Getting Started",
    "section": "On the blink",
    "text": "On the blink\nThe first program we shall run rejoices in the unlikely name of Blink. Click on File and select Examples from the drop-down menu. A further menu appears, with all the example programs. Select 01.Basics, followed by Blink (Figure 20.11).\n\n\n\n\n\n\nFigure 20.11: Select the blink example.\n\n\n\nSelect Blink. The program appears in a new IDE window (Figure 20.12`). The program at this stage is just text. It needs to be compiled in order to create an executable file.\n\n\n\n\n\n\nFigure 20.12: Blink program (Arduino sketch blink.ino) loaded in the Arduino IDE 2.\n\n\n\n\nFlowchart for Blink\nThe flowcharts for the blink program are shown in Figure 20.13 and Figure 20.14. These are the contents of the Arduino sketch suprocesses setup and loop shown in Figure 20.10.\nIn setup (Figure 20.13), the pin that is connected to the built-in on-board LED (LED_BUILTIN), is setup as an output1.\n\n\n\n\n\n\nFigure 20.13: Flow-chart for the setup sub-process for blink\n\n\n\nIn loop (Figure 20.14), the built-in LED is turned on as indicated by the I/O block. There is then a one second (1000 ms) delay indicated by the first subprocess. The built-in LED is then turned off, and there is another 1 second delay. Because the whole of the loop sub-process ends at this point, the return to the top of the sub-process shown in Figure 20.10 means that the whole process is repeated. The effect is that the LED will “blink” at the rate of 1 second on and 1 second off.\n\n\n\n\n\n\nFigure 20.14: Flow-chart for the loop sub-process for blink\n\n\n\n\n\nCode for Blink\nThe code for blink is reproduced below in Listing 20.1. It is clear how the program represented by the flow-charts in Figure 3.12, Figure 20.13 and Figure 20.14 are turned into subroutine calls in the ‘C’-program. Note that much of the code is comments\n\n\n\nListing 20.1: Blink program courtesy of the built-in Blink\n\n\n/*\n  Blink\n\n  Turns an LED on for one second, then off for one second, repeatedly.\n\n  Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO\n  it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to\n  the correct LED pin independent of which board is used.\n  If you want to know what pin the on-board LED is connected to on your Arduino\n  model, check the Technical Specs of your board at:\n  https://www.arduino.cc/en/Main/Products\n\n  modified 8 May 2014\n  by Scott Fitzgerald\n  modified 2 Sep 2016\n  by Arturo Guadalupi\n  modified 8 Sep 2016\n  by Colby Newman\n\n  This example code is in the public domain.\n\n  https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink\n*/\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)\n  delay(1000);                      // wait for a second\n  digitalWrite(LED_BUILTIN, LOW);   // turn the LED off by making the voltage LOW\n  delay(1000);                      // wait for a second\n}\n\n\n\n\n\nCompiling Blink\nIdentify the icon for compiling the program, this is a tick in a blue circle which is called Verify on the Arduino IDE. Click this once, and after a short period of time the message “Done compiling” should appear near the bottom of the window. Hopefully, as we are compiling an example program, there will be no errors! If there are errors, information on the type of error and where it has occurred in the program can be found in the dialogue box near the bottom of the window.\n\n\nUploading Blink\nNext, we need to transfer the executable file to the Arduino Nano board. This is done by identifying the icon Upload, which is a right arrow in a blue circle, and clicking it once. Annoyingly, the IDE insists on re-compiling the program. If all has gone to plan, the message “Done Uploading” appears. Then after a few seconds the executable file starts running on the Nano board. One of the LEDs begins flashing at a regular rate, one second on, one second off.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#modifying-blink",
    "href": "labs/get_started/index.html#modifying-blink",
    "title": "Getting Started",
    "section": "Modifying Blink",
    "text": "Modifying Blink\nSo far, so good.\nNow, let us try changing the program. Look at the text screen, the “source code”. You will find two instances of the instruction delay(1000).\nMove the cursor and change the argument of the two instructions to 100. Now, with your new-found knowledge, re-compile the program and upload it to the Nano.\nWhen the message “Done Uploading” appears, look at the LED on the Nano. It should be flashing at ten times the previous rate.\nCongratulations! You have successfully edited the program.\nYou should save the edited program by clicking on File, selecting “Save As” and when the dialogue appears, give the program a new name, for example “myblink”.\nHow would you change the flow chart in Figure 20.14 to document the change you made in the code? Put a copy of your modified flow-chart and a code listing in your lab diary. You will find a copy of the PowerPoint that we used to create the flow charts in this chapter on-line by following this link: eg-151-textbook/website/labs/get_started/pictures/flow-charts.pptx. You can use the diagrams in that PowerPoint file as a template for your own flow-charts.\nYou are now ready to attempt the first laboratory exercise: Experiment 1: Binary Counter.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/get_started/index.html#footnotes",
    "href": "labs/get_started/index.html#footnotes",
    "title": "Getting Started",
    "section": "",
    "text": "The built-in LED on the Arduino Nano board is connected to digital pin 13 which is GPIO pin 5 on port B. This port is not connected to any of the pins that come out of the Ardino Nano board (see Figure 3.12) and are available for connection to external I/O devices.↩︎",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html",
    "href": "labs/lab01/index.html",
    "title": "Experiment 1: Binary Counter",
    "section": "",
    "text": "How can the microcontroller make something happen?",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#how-can-the-microcontroller-make-something-happen",
    "href": "labs/lab01/index.html#how-can-the-microcontroller-make-something-happen",
    "title": "Experiment 1: Binary Counter",
    "section": "",
    "text": "The microcontroller on the Nano board has a number of parallel ports, which can be used to make something happen in the world outside the plastic package. Parallel ports are usually groups of eight pins, however on the Arduino Nano not all the pins are brought out to the edge of the board. So, working within this constraint, Experiment 1 will begin with the construction and programming of a six-bit binary counter, which can count from zero to \\(63\\) (\\(2^6 - 1\\)).",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#parallel-ports-and-data-direction-registers",
    "href": "labs/lab01/index.html#parallel-ports-and-data-direction-registers",
    "title": "Experiment 1: Binary Counter",
    "section": "Parallel ports and data direction registers",
    "text": "Parallel ports and data direction registers\nIn most microcontrollers, including the Atmel ATMega32 used in the Arduini Nano board, we set the digital port to be either an input or an output by setting a value in a special register, associated with the parallel port, which is called the Data Direction Register (DDR).\nThe DDR settings that provide the six outputs that we need for this experiment are shown in Table 21.1.\n\n\n\nTable 21.1: DDR for setting six outputs\n\n\n\n\n\nDDRC7\nDDRC6\nDDRC5\nDDRC4\nDDRC3\nDDRC2\nDDRC1\nDDRC0\n\n\n\n\n0\n0\n1\n1\n1\n1\n1\n1 0\n\n\n\n\n\n\nThere are two ways of setting the bits in the DDR. Individual bits can be set using an Arduino specific command, pinMode. For this experiment, we shall write directly to the DDR corresponding to Port C, which is designated DDRC in our programme. In the example shown above, the top two bits of Port C will be inputs (DDRC7=0, DDRC6 = 0) and all the remaining bits will be outputs. This is a more general way of setting a DDR in different versions of embedded “C”.\nWriting a number to the port register itself will cause a binary pattern to appear on the corresponding pins of the designated port, according to their binary weights. For example, bit 0 has a binary weight of \\(2^0 = 1\\), bit 1 has a binary weight of \\(2^1 = 2\\), bit 2 has a binary weight of \\(2^2 = 4\\), all the way up to bit 7 which has a binary weight of \\(2^7 = 128\\).",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#method",
    "href": "labs/lab01/index.html#method",
    "title": "Experiment 1: Binary Counter",
    "section": "Method",
    "text": "Method\nConstruct the circuit shown in Figure 21.1 using the components supplied in your laboratory kit:\n\n\nCounter circuit.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#our-first-programme",
    "href": "labs/lab01/index.html#our-first-programme",
    "title": "Experiment 1: Binary Counter",
    "section": "Our First Programme",
    "text": "Our First Programme\nNow you are familiar with the Arduino IDE from running “Blink” in section on the blink, the next step is to write a new programme.\nListing 21.1 shows the text of a program which will illuminate the LEDs in a binary sequence, starting from zero (all LEDs off) to 63 (all LEDs on). Then the LEDs will go back to zero. The time it takes to count is controlled by a “time wasting” delay, using the Arduino specific command delay().\nFirst connect your Arduino Nano board to your PC with the cable provided. Next open Arduino IDE 2 and select the connection and board as described in section initial set up. From the file menu select “New Sketch”. Click on the small clipboard icon at the top-right corner of the code listing Listing 21.1 () to copy the code and paste it into the code window of the new sketch. Save the sketch file as counter1.\nTHE Arduio IDE will close then reopen with the code for a new Sketch project called counter1.ino loaded in the code editor as shown in Figure 21.1.\n\n\n\n\n\n\nFigure 21.1: Our first program ready for testing.\n\n\n\nNow that the file has been entered into the computer and an Arduino sketch project it must be converted into a form the Arduino board can accept. This operation is called compilation.\nClick on the icon which starts the compilation. This is the blue tick near the top of the window, also called Verify. After a few seconds, the display area at the bottom of the window should say “compilation complete”. If it does not, and some error message appears, check carefully that the program has been entered correctly and try again.\nWhen the program has been compiled successfully, it must be uploaded to the Arduino. Click on the blue arrow near the top of the window, called Upload. This operation should only take a few seconds. The message “Done uploading” tells us that the upload operation has been successful, and the LEDs should start counting.\nIf the upload fails, there are a number of things to check. Under “tools”, there are a number of settings, e.g.\n\nBoard type: Arduino Nano\nProcessor: ATmega328P\nPort: /dev/ttyUSB0 (for example only; this will differ for PC and Mac)\n\nIf the above are wrong, then the upload will fail. Ask a demonstrator for help!",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#lets-make-a-decision",
    "href": "labs/lab01/index.html#lets-make-a-decision",
    "title": "Experiment 1: Binary Counter",
    "section": "Lets make a decision",
    "text": "Lets make a decision\nThe flow-charts for Listing 21.1 is given in Figure 21.2 and Figure 21.3. Note that the codes are similar to the flow-charts given in Getting Started. There are just a couple of steps in the setup sub-process and one less output task in the loop. Note also that we have used english statements rather than code in the block labels.\n\n\n\n\n\n\nFigure 21.2: Flow-chart of the setup sub-process for the first program\n\n\n\n\n\n\n\n\n\nFigure 21.3: Flow-chart of the loop sub-process for the first program\n\n\n\nThe example program counts from zero to 255 and then back to zero, though we see the LEDs being illuminated from zero to 63 as there are only six LEDs. The counts from 64 to 127 look just the same as zero to 63! As the counter is only 8 bits, when we get to 255, the counter is reset to 0. This behaviour is not obvious from the flow-chart for the loop subprocess.\nSupposing we need a counter that counts from zero to 59, and then back to zero. This is often required, for example in time-keeping programmes (60 seconds in a minute, 60 seconds in an hour). The number of count values (60 in this case) is called a Modulus.\nThere are several ways we can add a modulus to our counter programme. Here we will use a decision.\nIf we add a decision block to the flow chart for the loop, as shown in Figure 21.4, we can control the maximum count that can occur.\n\n\n\n\n\n\nFigure 21.4: Flow-chart of the loop sub-process with a decision block used to limit the maximum value of the counter to 59\n\n\n\nThe code that corresponds to the decision block in Figure 21.4 is\ncounter = counter + 1;\nif (counter &gt; 59) {\n  counter = 0;\n}\nIn this code, we have made a decision! If the value of the variable counter is increased beyond 59, then it will be set back to zero, so the LEDs never advance beyond 59.\nWhy bother with counts greater than 60? Well, if the program is not properly initialised then there will be a number of false counts.\nIf you are not familiar with “C” programming, then you will notice that there are two kinds of “equals” in the extra line. The “greater than” (&gt;) is a comparison and does not change any values. In other words the value of the variable counter is compared with the fixed value of 59. If the condition is true, then the contents of the “braces” (squiggly brackets) are executed. The single equals (=) is an assignment and forces the value of the variable to the fixed value zero.\nJust to make life more interesting, in “C” there is a “double equals” ==). This can be a source of confusion when starting to program in the “C” language. It is used to compare two numbers, for example as follows:\ncounter = counter + 1;\nif (counter == 60) {\n  counter = 0;\n}\n\nThere are lots of “C” commands which reduce the amount of text that you have to write. For example, instead of adding 1 to the variable counter1 we can use the increment operator (++) to increment a variable by 1:\ncounter++;\nThis has the same effect as adding “1” to the variable counter and reassigning the new value to counter which is what:\ncounter = counter + 1;\ndoes.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#lets-do-it-again",
    "href": "labs/lab01/index.html#lets-do-it-again",
    "title": "Experiment 1: Binary Counter",
    "section": "Lets do it again!",
    "text": "Lets do it again!\nNow that we are masters of the modulus counter, lets repeat the operation by connecting another set of LEDs to port B, and adding extra lines to the program as shown in Listing 21.2.\nThis will require another variable, for example “counter2”.\nIn addition, let us increment counter1 when counter2 overflows, (changes from 59 to zero) so that one set of LEDs is counting in seconds and the other set of LEDs is counting in minutes.\nAdd another set of six LEDs and resistors to the Breadboard as shown in Figure 21.5.\n\n\n\n\n\n\nFigure 21.5: Circuit board for a cascaded counter.\n\n\n\nModify the program to include the extra lines and compile then upload. If this is successful, then the LEDs on port B will count as far as 59 (0b0111011) and then all go out and start counting again. At the instant the LEDs on port B go out, the LEDs on port C will advance by one. So, if we have the patience, after an hour the LEDs will reach their maximum value of 59 minutes, 59 seconds (0b0111011 0b0111011) and all go out. Then the counter starts counting again from all zeros.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#lets-do-it-differently",
    "href": "labs/lab01/index.html#lets-do-it-differently",
    "title": "Experiment 1: Binary Counter",
    "section": "Let’s do it differently",
    "text": "Let’s do it differently\nSo far we have used simple arithmetic operations such as addition to increment the variables, then compare with a fixed modulus. An alternative is to use a for(;;) loop.\nLet’s look at the elements of a for(;;) loop:\nfor (variable = initial value; condition to be met; operation on variable) {\n   code to be executed in for loop;\n}\nA better way of understanding the for(;;) loop is to look at a practical example;\nfor (counter2 = 0; counter2 &lt; 60; counter2++) {\n  PORTB = counter2;\n  delay(1000);\n}\nIn just three lines of code, the start and end values of the loop are set up, and the increment defined, followed by the code to be executed each time around the loop. This illustrates the compact nature of the “C” language.\nThis for(;;) loop only executes once, so we still need to make it repeat, which is made possible by the loop function in the Arduino program. Suppose we embed this for(;;) loop in an outer for(;;) loop, which increments a different variable and writes to a different port? Then we will have achieved the same result as the program in Listing 21.2, but in a more elegant fashion:\nfor (counter1 = 0; counter1 &lt; 60; counter1++) {\n    PORTC = counter1;\n    for (counter2 = 0; counter2 &lt; 60; counter2++) {\n        PORTB = counter2; \n        delay(1000)\n    }\n}\nThe “heart” of the program is just a few lines of code!\nModify the program as shown in Listing 21.3, compile and upload, and check that it really does what we expect. You may find it convenient to reduce the delay from 1000 to speed up the operation of the counters.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#assessment-of-experiment-1",
    "href": "labs/lab01/index.html#assessment-of-experiment-1",
    "title": "Experiment 1: Binary Counter",
    "section": "Assessment of Experiment 1",
    "text": "Assessment of Experiment 1\nOpen the document you are using as a laboratory diary and add a new section “Experiment 1”.\nCreate a flow-chart of the cascaded counter from the code given in Listing 21.2.\nTake a photograph of the completed breadboard, with the twelve LEDs and resistors fitted. Include in your photo some means of identification, such as your student card.\nWhen you have finished modifying the program to correspond with Listing 21.3, add some comments (preceded by the double oblique stroke “//”) and copy the text from the Arduino IDE and paste it into your laboratory diary as a code listing.\nRedraw the flow chart to reflect the order of operation of the for loops. Hint: A flow chart for a nested for-loop like the one used in Listing 21.3 is given in Figure 5.10. Comment on any differences in flow-charts between that for Listing 21.2 and that for Listing 21.3.\nWe shall be expecting the flow-charts and code comments to demonstrate your understanding of the way the nested for(;;) loop works.\nWhy are comments so important? If someone else reads the program, the comments aid understanding. Also, if you return to working on a program after a couple of weeks, it is much easier to pick up where you left off.\nA program without comments is incomplete!\nDon’t forget to add to your lab diary entry some discussion of the results and a reflection on the outcomes of this first experimeent.\n\n\n\n\n\n\nWarning\n\n\n\nLab 1 cannot be signed off unless the lab diary contains the two flow-charts for Listing 21.2 and Listing 21.2, the code listing for Listing 21.3 with added comments, and a photograph of the completed modular-60 counter.\n\n\n\n\n\n\n\n\nNote\n\n\n\nDiscussion, conclusions and reflection are not needed for the experiment sign-off but are required for the final lab-diary submission.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#code-listings",
    "href": "labs/lab01/index.html#code-listings",
    "title": "Experiment 1: Binary Counter",
    "section": "Code Listings",
    "text": "Code Listings\n\nBasic counter\n\n\n\nListing 21.1: Basic counter.\n\n\n// Declare variable to be used as a counter.\n  // This has to be done outside `setup` and `loop` so that `counter` is visible\n  // inside both functions\nbyte counter;\n\n// The setup function runs once when you press reset or power the board\nvoid setup() {\n    // initialize counter\n    counter = 0; \n\n    // Set pins 0-5 of Port C as outputs.\n    DDRC = 0b00111111; // the prefix &ldquo;0b&rdquo; qualifies the number as binary\n    PORTC = 0; // so all the LEDs are off initially\n}\n\n// The loop function runs repeatedly forever\nvoid loop() {\n    PORTC = counter;\n    \n    // increment counter\n      // we could replace the next line with: counter1++;\n      // or the previous line with PORTC = counter1++;\n    counter = counter + 1;\n\n   // Uncomment the following three lines for a modulus of 60: \n    // if (counter &gt; 59) {\n    //     counter = 0;\n    // }\n    delay(1000); // reduce the delay if you get bored waiting!\n\n}\n\n\n\nView and download the code from GitHub gist counter.ino.\n\n\nWokwi simulation of basic counter\nYou can run a wokwi simulation of this circuit which was created by EEE project student Yousef Alsayegh (class of 2024-2025). The link is Lab 1: Basic counter. You can extend the circuit by adding 6 further LEDs connected as in Figure 21.5 and use Listing 21.2 to implement the cascased modulo 60 counter. You can then paste your commented version of Listing 21.3 into the simulator’s code window to simulate final example.\nIf you succeed, it would be useful to provide links to the simulations in your lab diary.\n\n\nCascaded counter\n\n\n\nListing 21.2: Cascaded counter.\n\n\n// Declare variables to be used as counters.\nbyte counter1, counter2;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n    // define counters\n    counter1 = 0; counter2 = 0; // initialize counters\n\n    // initialize Ports B and C pins 0-5 as outputs.\n    DDRB = 0b00111111; DDRC = 0b00111111;\n\n    PORTB = 0; PORTC = 0; // both ports start from zero\n}\n\n// the loop function runs repeatedly forever\nvoid loop() {\n    PORTB = counter2; // counter2 is our \"seconds\" counter\n    PORTC = counter1; // counter1 is our \"minutes\" counter\n\n    counter2++; // using the tip we learnt earlier\n    if (counter2 &gt; 59) {\n        counter2 = 0;\n        counter1++;\n        if (counter1 &gt; 59) {\n            counter1 = 0;\n        }\n    }\n\n    delay(1000); // again, reduce this delay if necessary to speed things up.\n}\n\n\n\nView and download the code from GitHub gist counter2.ino.\n\n\nCounter using for loop\n\n\n\nListing 21.3: Counter using for-loop.\n\n\n// declare counters\nbyte counter1, counter2;\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n    // initialize counters\n    counter1 = 0; counter2 = 0; \n\n    // initialize Ports B and C pins 0-5 as outputs.\n    DDRB = 0b00111111; DDRC = 0b00111111;\n\n    PORTB = 0; PORTC = 0; // both ports start from zero\n}\n\n// the loop function runs repeatedly forever\n\nvoid loop() {\n\n    for (counter1 = 0; counter1 &lt; 60; counter1++) {\n        PORTC = counter1;\n        for (counter2 = 0; counter2 &lt; 60; counter2++) {\n            PORTB = counter2;\n            delay(1000);\n        }\n    }\n}\n\n\n\nView and download the code from GitHub gist counter3.ino.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab01/index.html#photographs-of-plug-in-breadboard",
    "href": "labs/lab01/index.html#photographs-of-plug-in-breadboard",
    "title": "Experiment 1: Binary Counter",
    "section": "Photographs of Plug-in Breadboard",
    "text": "Photographs of Plug-in Breadboard\nThe following photographs (Figure 21.6 and Figure 21.7) were provided by Dr Davies who created this experiment.\n\n\n\n\n\n\nFigure 21.6: Photograph of partially wired prototype board.\n\n\n\n\n\n\n\n\n\nFigure 21.7: Photograph of completed prototype board for experiment 1.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Experiment 1: Binary Counter</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html",
    "href": "labs/lab02/index.html",
    "title": "Experiment 2: Digital Input",
    "section": "",
    "text": "Connecting a switch to a port\nHow do we connect a switch to a port pin? There are various possibilities as shown in Figure 22.1.\nOption “A” looks good, but there are several problems. It requires a “change over” switch, with connections to both contacts. In addition, when the switch is in motion from “0” to “1” there is a brief period when the port voltage is undefined, which can result in unpredictable operation. For example, it could be seen as multiple operations of the switch.\nOption “B” is much better. It only requires a “single pole” switch, which is the usual configuration for a keyboard. In addition, the voltage on the port is always defined; logic “0” when the switch is open, logic “1” when it is closed.\nOption “C” has the same advantages as option “B”, though of course the switch action is reversed – logic “1” when the switch is open, logic “0” when the switch is closed. Historically, switch inputs on digital circuits tend to be of this type, which is known as “active low” switching. In fact, this option is supported by the internal hardware of the microcontroller, which has built-in resistors so all that is required is an external switch connected between the port and logic “0”.\nThis is the case for the hardware that we are using and is illustrated in Figure 22.2.\nEach port has an associated pull-up register, which allows individual bits of the port to be “tied” to logic “1” through a high-value resistor. Different families of microcontrollers have different mechanisms for achieving this. In the demonstration programthat follows, the input pull-up resistors are enabled by a Arduino specific instruction, pinMode(). Another microcontroller used in our undergraduate labs, the “AW60”, has special registers called “pull-up enable” registers to perform the same task.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#connecting-a-switch-to-a-port",
    "href": "labs/lab02/index.html#connecting-a-switch-to-a-port",
    "title": "Experiment 2: Digital Input",
    "section": "",
    "text": "Figure 22.1: Three ways to connect a switch to a port.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 22.2: Active low switching for a microcontroller.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#using-a-switch-in-a-programme",
    "href": "labs/lab02/index.html#using-a-switch-in-a-programme",
    "title": "Experiment 2: Digital Input",
    "section": "Using a switch in a programme",
    "text": "Using a switch in a programme\nThe demonstration program illustrated as a flow-chart in Figure 22.4 in Listing 22.1 is, in fact, the very first program we tried in Experiment 1. There is one refinement; a switch is tested and if the logic input is “0”, the counter does not advance. Notice the pinMode() instruction in setup(), which turns on the internal pull-up resistor. This is a one-off instruction at the start of program execution.\nCreate an Arduino sketch, and copy/paste the code from Listing 22.1 into it.\nThe testing of the switch input could be done using an Arduino-specific instruction, digitalRead(), but for the sake of completeness here is how it can be done using a port read and a logical “and” operation. The designated port is port D, bit 2. Note the use of the exclamation mark (“!”); “!=” means “does not equal”.\nif ((PIND & 0b00000100) != 0) { \n  counter2++; \n}\nThis will work with a wide range of different microcontrollers and “C” compilers. Note the use of the ampersand (“&”) which is the logical “and” operation. The equivalent using an Arduino specific command is as follows:\nif ( digitalRead(2) != 0 ) {\n    counter2++;\n}\nThe argument of the digitalRead()operation, 2, is part of the “shorthand” used by Arduino programmers to designate a particular port pin. It has the advantage of being consistent over a wide range of boards in the Arduino family.\nAdd the two push button switches to the plug-in breadboard, using pin-to-pin leads ans shown in Figure 22.3. Take great care when mounting the switches on the breadboard, to orient them correctly, and to avoid bending the little tabs!\nWhen the program runs, the LEDs on Port C will count up as before. When the left-hand button is pressed, the counter stops and resumes when the button is released. We are “in control” of the counter!\n\n\n\n\n\n\nFigure 22.3: Wiring diagram for Experiment",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#lets-go-faster",
    "href": "labs/lab02/index.html#lets-go-faster",
    "title": "Experiment 2: Digital Input",
    "section": "Let’s go faster",
    "text": "Let’s go faster\nThe next program, in Listing 22.2, uses both buttons. The left-hand button, as before, stops the counter. The right-hand button is a “turbo” button, and makes the counter speed up by a factor of 10!\nA new program structure, if...else has been introduced Listing 22.2 (lines 28—33) is used to decide on a delay of 1000 ms or a delay of 100 ms, depending on the condition of the button.\nThe general if…else structure is as follows:\nif (condition 1) {\n    operation 1\n} else {\n   operation 2\n}\nAn additional program structure, else if, can replace else if there are multiple decisions.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#sec-section-5",
    "href": "labs/lab02/index.html#sec-section-5",
    "title": "Experiment 2: Digital Input",
    "section": "An exercise for the reader…",
    "text": "An exercise for the reader…\nThe last part of Experiment 2 is an exercise for the reader. Do not despair, all the program elements needed have been covered in this Experiment and Experiment 1.\nModify the program in Listing 22.2 so that the buttons have this effect:\n\nIf no buttons are pressed, a counter on Port C and a counter on Port B increment at the same rate, with a delay of 1000 ms so that the LEDs seem to be counting identically.\nIf the left button is pressed, the LEDs on Port C stop counting but the LEDs on Port B continue as before.\nIf the right button is pressed, the LEDs on Port B stop counting but the LEDs on Port C continue as before.\nIf both buttons are pressed, both sets of LEDs stop counting but resume when the buttons are released.\n\nA hint: there are four distinct parts inside loop(); first of all, update both sets of LEDs. Then test one button and make a decision to increment counter 1 or not. Then test the other button and do the same for counter 2. Finally, adjust the delay.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#assessment-of-experiment-2",
    "href": "labs/lab02/index.html#assessment-of-experiment-2",
    "title": "Experiment 2: Digital Input",
    "section": "Assessment of Experiment 2",
    "text": "Assessment of Experiment 2\nThis follows the pattern set in Experiment 1.\n\nA photograph of the modified breadboard, with some form of identification.\nA flow-chart of your final program as specified in An exercise for the reader… above.\nA listing of your final program with suitable comments.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#code-listings-and-flow-charts",
    "href": "labs/lab02/index.html#code-listings-and-flow-charts",
    "title": "Experiment 2: Digital Input",
    "section": "Code Listings and Flow-Charts",
    "text": "Code Listings and Flow-Charts\n\nBinary counter with stop/start control\n\n\n\n\n\n\nFigure 22.4: Flow-chart for binary counter with stop/start control.\n\n\n\n\n\n\nListing 22.1: Binary counter with stop/start control.\n\n\n// define variables\nbyte counter1, counter2; // counter2 is not used in this program\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n\n    counter1 = 0;  // Initialize counter 1\n    \n    // initialize Ports B and C pins 0-5 as outputs.\n    DDRB = 0b00111111; DDRC = 0b00111111;\n\n    PORTB = 0; PORTC = 0; // both ports start from zero\n\n    pinMode(2, INPUT_PULLUP); // Make bit 2 of Port D an input\n}\n\n// the loop function runs repeatedly forever\nvoid loop() {\n\n    PORTC = counter1;\n\n    // if (digitalRead(2) != 0){counter1++;}\n\n    if ((PIND & 0b00000100) != 0) {\n        counter1++;\n    }\n\n    // either of the two lines above can be used\n\n    delay(1000); // reduce this delay for faster counting\n}\n\n\n\nView and download code as a GitHub gist: digi_input1.ino.\n\n\nWokwi simulation of binary counter with stop/start control\nYou can run a wokwi simulation of this circuit which was created by EEE project student Yousef Alsayegh (class of 2024-2025). The link is Lab 2: Binary counter with stop/start control and it uses the code from Listing 22.1. You can copy and edit this to create your own simulation the binary counter with stop/start and turbo button using the code from Listing 22.2.\nIf you do, it would be useful to provide links to the simulations in your lab diary.\n\n\nBinary counter with stop/start and turbo button\n\n\n\nListing 22.2: Binary counter with stop/start and turbo button.\n\n\n// define variables\nbyte counter1,counter2; // counter2 is not used in this programme\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n    // initialize counter\n    counter1 = 0;\n\n    // initialize Ports B and C pins 0-5 as outputs.\n    DDRB = 0b00111111; DDRC = 0b00111111;\n    \n    // both ports start from zero\n    PORTB = 0; PORTC = 0;\n\n    pinMode(2, INPUT_PULLUP); // Make bit 2 of Port D an input\n    pinMode(3, INPUT_PULLUP); // Make bit 3 of Port D an input\n}\n\n// the loop function runs repeatedly forever\nvoid loop() {\n\n    PORTC = counter1;\n\n    if (digitalRead(2) != 0) {\n        counter1++;\n    } // same decision as previous\n\n    if (digitalRead(3) != 0) {\n        delay(1000);\n    } // long delay is default\n    else {\n        delay(100);\n    } // short delay if button is pressed\n}\n\n\n\nView and download code as a GitHub gist: digi_input2.ino.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab02/index.html#photograph-of-experiment-2",
    "href": "labs/lab02/index.html#photograph-of-experiment-2",
    "title": "Experiment 2: Digital Input",
    "section": "Photograph of Experiment 2",
    "text": "Photograph of Experiment 2\nThe following photograph (Figure 22.5) has been provided by Dr Davies who created this experiment.\n\n\n\n\n\n\nFigure 22.5: Photograph of the completed prototype board for Experiment 2.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Experiment 2: Digital Input</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html",
    "href": "labs/lab03/index.html",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "",
    "text": "Analogue to Digital Conversion\nIt has been said many times that we live in a digital world. This is not true! We live in an analogue world, filled with voltages, currents, temperatures, pressures – all quantities which vary continuously and can be measured with great accuracy. The digital world wants everything neat and tidy, on or off, hot or cold, zero or one: which is not necessarily compatible with the analogue world. In order to access analogue information in a digital system, an Analogue to Digital Converter (ADC) is needed.\nThe transfer characteristic of a 10-bit ADC is shown in the Figure 23.1 above. Let us suppose that the analogue input voltage, Vin, can be anywhere between zero Volts and Vref. As \\(V_\\mathrm{in}\\) increases, the binary output varies from all zeros when \\(V_\\mathrm{in} = 0\\), and all ones when \\(V_\\mathrm{in} = V_\\mathrm{ref}\\).\nNow, the previous statement is only 99.9% true, as will be explained. Suppose \\(V_\\mathrm{ref} = 5\\) V. Then each step shown on the graph above, is equivalent to \\((5\\,\\mathrm{V} / 1024)\\) which is (nearly) 5 mV. So the maximum voltage that can be measured is not, strictly, \\(V_\\mathrm{ref}\\), it is \\(V_\\mathrm{ref}\\) minus one step! In our example, that will be \\((5\\,\\mathrm{V} - 5 \\mathrm{mV})\\) which is a tiny fraction over 4.995 V.\nThe primary characteristic of an ADC is this figure N, the number of bits. It tells us the RESOLUTION of the ADC. Another important characteristic is the conversion time, which determines how many conversions can be performed per second.\nSome examples of ADCs. Suppose we want an ADC to convert high quality digital audio signals. Then the minimum value of N would be 16, in order to give an acceptable resolution. With N = 16, there will be 216 steps on the conversion graph, which is 65,536. The conversion speed is related to the audio bandwidth required. Most computers and tablets use ADCs which give 48,000 samples per second, which is \\(22\\,\\mu\\mathrm{s}\\) per conversion. This is a high specification, as it is necessary in order to produce clean digitised audio with a high bandwidth.\nThat was the “Rolls-Royce” ADC. Suppose we need an ADC capable of digitising audio for a telephone line. The bandwidth of the audio signal on telephone lines is typically 3.5 kHz, and the internationally agreed conversion speed is 8000 conversions per second, corresponding to 125 us per conversion. The resolution need only be 8 bits to give acceptable telephone quality, corresponding to 28 = 256 steps. So the ADC needed for telephone quality has a much lower specification than the one for high quality digital audio. We shall not extend the metaphor of the make of motor car, in case of legal action.\nThe ADC inputs on our Arduino Nano are 10 bits resolution and can be sampled at a maximum of about 10 kHz, so they easily meet the specification for telephone lines on speed and resolution but are a bit short of the resolution and speed for high quality audio.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#analogue-to-digital-conversion",
    "href": "labs/lab03/index.html#analogue-to-digital-conversion",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "",
    "text": "Figure 23.1: Analogue to Digital Conversion",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#reading-an-analogue-input",
    "href": "labs/lab03/index.html#reading-an-analogue-input",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "Reading an Analogue Input",
    "text": "Reading an Analogue Input\nThe Analogue to Digital Converter on the Arduino Nano has six inputs which are shared with other functions, and two inputs which are exclusively analogue inputs. The command to read from an analogue input is of the form analogRead(), where the brackets contain an expression which specifies the analogue input. Note that the hardware only permits one conversion at a time, so if we want to read the value from all eight inputs this will require eight separate analogRead() instructions. This can be an issue if we need to read several voltages simultaneously, which requires additional hardware external to the Arduino Nano.\nIf you look in Listing 23.1, you will find a simple program which repeatedly reads from analogue input 6 (A6) and displays the value on the LEDs. The source of the voltage to be measured is from a potentiometer, which is a resistor with a moving contact which can be used to give a fraction of the voltage across the ends. As the wheel on the potentiometer is rotated, the fraction of the voltage varies from zero to 100%.\nThere is a slight problem. There are only six LEDs connected to Port C, which gives a maximum number of \\((2^6 - 1) = 63\\). However, the number read from the ADC has a maximum value of \\((2^{10} - 1) = 1023\\). So, as a “cheat”, the value of analogRead() is divided by 16 so that it fits!\nModify the plug-in breadboard by adding the supplied potentiometer and connecting it as shown in Figure 23.2, using wire links cut from the supplied single-core cable using the wire cutter and stripper. Don’t forget to wear eye protection when cutting the wires!\n\n\n\n\n\n\nFigure 23.2: Circuit layout for Experiment 3.\n\n\n\nCreate an Arduino sketch in the usual way and copy the code from Listing 23.1 into it. Compile and download the code. When the programme is running, turn the potentiometer slowly. You will see the LEDs light up in a binary sequence, so that no LEDs are illuminated when the wheel is fully anticlockwise, and all the LEDs are illuminated when the wheel is fully clockwise. Try and find a position where the LEDs change over from 011111 (31 decimal) to 100000 (32 decimal). This should be exactly half-way between the extreme positions.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#bar-graph-display",
    "href": "labs/lab03/index.html#bar-graph-display",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "Bar Graph Display",
    "text": "Bar Graph Display\nThe next demonstration program is of a bar graph display. Instead of illuminating in a binary sequence, the LEDs light progressively from one end to the other in the same way as the volume indicator on digital record and playback equipment. The number from the ADC has a maximum value of 1023, and there are only six LEDs. So the number from the ADC must be scaled. Let us pretend that 1024/6 = 170.\nADC = 0; no LEDs lit.\nADC = 1 to 170: one LED lit.\nADC = 171 to 341: two LEDs lit.\nADC = 342 to 512: three LEDs lit.\nADC = 513 to 683: four LEDs lit.\nADC = 684 to 853: five LEDs lit.\nADC = 854 to 1023: six LEDs lit.\nHow are we to implement this set of decisions in code? One solution would be to use a series of if() statements, however some slight additions are needed. We actually need anif() … else statement, so that only one of the conditions causes a write to the LEDs. If you look at the program in Listing 23.2, you will see that it begins its tests with the highest threshold and progresses down in steps of 170 until zero.\nA flow-chart of this decision tree which is inside the loop subprocess in Listing 23.2 is given in Figure 23.3.\nThe setup subprocess is almost the same as that used in Figure 21.2 and is not reproduced here.\n\n\n\n\n\n\nFigure 23.3: The partially complete decision tree for the bar-chart display.\n\n\n\nCopy/paste the program in Listing 23.2 into an Arduino sketch, compile and test. As you rotate the wheel on the potentiometer clockwise, progressively more LEDs will light. If you balance the setting so that it is just changing over from three LEDs to four, this is exactly halfway on the potentiometer (arrow pointing upwards).",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#sec-ex3-exercise",
    "href": "labs/lab03/index.html#sec-ex3-exercise",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "An Exercise for the Reader",
    "text": "An Exercise for the Reader\nNow that we are familiar with the concept, let us write a program to illuminate all twelve LEDs as a bar graph. The following changes will need to be made to the program in Listing 23.2:\nBoth Port B and Port C will need to be updated after each if()statement, e.g.\nPORTC = 0b00000011; \nPORTB = 0b00111111; \nwill result in the top two LEDs off, all other LEDs on.\nThe threshold numbers will go up in steps of \\((1024 / 12)\\) which is approximately 85.\nCreate a new Arduino sketch and modify the program from Listing 23.2. When you test it, the LEDs should light progressively as the potentiometer is rotated clockwise. When the potentiometer is at the extreme anticlockwise position, all LEDs will be out.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#assessment-of-experiment-3",
    "href": "labs/lab03/index.html#assessment-of-experiment-3",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "Assessment of Experiment 3",
    "text": "Assessment of Experiment 3\nAdd a sub-title “Experiment 3” to your lab diary, and include the following:\n\nA photo of the modified breadboard, with the potentiometer added. Don’t forget to include identification.\nA truncated flow-chart of the modified decision tree for 12 LEDs which should include the decision at\nthe centre1 of the range.\nA listing of your program for An Exercise for the Reader above, with comments as appropriate.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#code-listings",
    "href": "labs/lab03/index.html#code-listings",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "Code listings",
    "text": "Code listings\n\nListing 6: Simple application of analogRead().\n\n\n\nListing 23.1: Simple application of analogRead()\n\n\n// the setup function runs once when you press reset or power the board\n\nword ADCval = 0;\n\nvoid setup() {\n\n    // initialize Ports B and C pins 0-5 as outputs.\n\n    DDRB = 0b00111111;\n    DDRC = 0b00111111;\n\n    PORTB = 0; // both ports start from zero\n    PORTC = 0;\n}\n\n// the loop function runs over and over again forever\n\nvoid loop() {\n\n    PORTC = (analogRead(A6)) / 16; // and that’s the active bit of the programme!\n}\n\n\n\nView or download code from GitHub Gist analog.ino.\n\n\nBar Graph display with six LEDs\n\n\n\nListing 23.2: Bar Graph display with six LEDs\n\n\n// the setup function runs once when you press reset or power the board\n\nword ADCval;\n\nvoid setup() {\n\n    // initialize Ports B and C pins 0-5 as outputs and set them to zero initially\n\n    DDRB = 0b00111111;\n    DDRC = 0b00111111; // may as well put them on the same line\n\n    PORTB = 0;\n    PORTC = 0; // and these statements too\n}\n\n// the loop function runs over and over again forever\n\nvoid loop() {\n\n    ADCval = analogRead(A6);\n\n    if (ADCval &gt;= 854) {\n        PORTC = 0b00111111;\n    } // all six LEDs on\n    else if (ADCval &gt;= 684) {\n        PORTC = 0b00011111;\n    } // five LEDs on\n    else if (ADCval &gt;= 513) {\n        PORTC = 0b00001111;\n    } // four LEDs on\n    else if (ADCval &gt;= 342) {\n        PORTC = 0b00000111;\n    } // three LEDs on\n    else if (ADCval &gt;= 171) {\n        PORTC = 0b00000011;\n    } // two LEDs on\n    else if (ADCval &gt;= 1) {\n        PORTC = 0b00000001;\n    } // one LED on\n    else {\n        PORTC = 0; // all LEDs off\n    }\n}\n\n\n\nView or download code from GitHub Gist bar_graph.ino.\n\n\nWokwi simulation of bar graph display with six LEDs\nYou can run a wokwi simulation of this circuit which was created by EEE project student Yousef Alsayegh (class of 2024-2025). The link is Lab 6: Bar graph display with six LEDs and it uses the code from Listing 23.2. You can copy and edit this to create your own simulation the bar Graph display with twelve LEDs.\nIf you do, it would be useful to provide links to the simulations in your lab diary.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#photographs",
    "href": "labs/lab03/index.html#photographs",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "Photographs",
    "text": "Photographs\nThe following photograph (Figure 23.4) has been provided by Dr Davies who created this experiment.\n\n\n\n\n\n\nFigure 23.4: Photograph of the plug-in breadboard after completing Experiment 3.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab03/index.html#footnotes",
    "href": "labs/lab03/index.html#footnotes",
    "title": "Experiment 3: Analogue to Digital Conversion",
    "section": "",
    "text": "At the centre point PORTC = 0b00000000 and PORTB = 0b11111111.↩︎",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Experiment 3: Analogue to Digital Conversion</span>"
    ]
  },
  {
    "objectID": "labs/lab04/index.html",
    "href": "labs/lab04/index.html",
    "title": "Experiment 4: Arrays",
    "section": "",
    "text": "Arrays\nAn array is a list of items, which could be numbers, or alphabetic characters, accessible by specifying the position in the list. Setting up an array in “C” begins with specifying what each item is:\nspecifies that each item in the array is one byte, and that there are six items.\nsimilarly specifies that each item is an (16-bit wide) integer, and that there are 10 items.\nOther array types are possible, which are specified using the same notation as for variables.\nThe contents of an array can be specified at the same time as the array is defined, for example:\nsets up an array called numbers, containing the positive integers 1, 2, 3…\nListing 24.1 is a program which sets up an array containing integers, fetches them out of the array one at a time and displays them on one of the sets of LEDs. A short delay allows the numbers to be read, otherwise they would flash by too quickly to see! After displaying the individual numbers, the sum of the numbers is displayed for a longer period, then it starts all over again.\nCreate an Arduino sketch and paste in the program from Listing 24.1. Change the digits in the array to correspond to the digits in your student number; if your student number has six digits, begin with a leading zero so that there are seven items in the array.\nLook at the for(;;)loop in the programme. It starts at zero, because in “C” array index numbering starts from zero.\nCompile and upload the programme, then check that the digits of your student number are displayed in order and that the sum of the digits is correct. You do not need to make any changes to the plug-in breadboard.\nDraw a flow-chart of the program listed in Listing 24.1.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Experiment 4: Arrays</span>"
    ]
  },
  {
    "objectID": "labs/lab04/index.html#arrays",
    "href": "labs/lab04/index.html#arrays",
    "title": "Experiment 4: Arrays",
    "section": "",
    "text": "byte arrayname[6]; \n\nword anothername[10]; \n\n\n\n byte numbers[6] = {1,2,3,4,5,6};",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Experiment 4: Arrays</span>"
    ]
  },
  {
    "objectID": "labs/lab04/index.html#exercise",
    "href": "labs/lab04/index.html#exercise",
    "title": "Experiment 4: Arrays",
    "section": "Exercise",
    "text": "Exercise\nNow that you have the program from Listing 24.1 as a model, write a program as follows:\n\nCreate two arrays, one containing your student number and the other containing the last 7 digits of your telephone number.\nWrite a program which examines the two buttons. If neither button is pressed, continue checking the status of the buttons (look at Experiment 2 for a reminder how to examine the buttons).\nIf the left button is pressed, use the program from Listing 24.1 to read and display the contents of one of the arrays, finishing with displaying the sum of the digits.\nUse the other button to read and display the contents of the second array.\nWhen the display operation is complete, return to examining the switches.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Experiment 4: Arrays</span>"
    ]
  },
  {
    "objectID": "labs/lab04/index.html#assessment-of-experiment-4",
    "href": "labs/lab04/index.html#assessment-of-experiment-4",
    "title": "Experiment 4: Arrays",
    "section": "Assessment of Experiment 4",
    "text": "Assessment of Experiment 4\nWhen you are satisfied with the programme, copy and paste it into you lab diary. Don’t forget to put in plenty of comments (preceded by the double oblique stroke, “//”.)\nDraw a flow chart of the program with two arrays.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Experiment 4: Arrays</span>"
    ]
  },
  {
    "objectID": "labs/lab04/index.html#code-listing",
    "href": "labs/lab04/index.html#code-listing",
    "title": "Experiment 4: Arrays",
    "section": "Code Listing",
    "text": "Code Listing\n\nProgram using an array.\n\n\n\nListing 24.1: Program using an array.\n\n\n// the setup function runs once when you press reset or power the board\n\nint total; // This variable will contain the running total.\n\nint numbers[7] = {2, 9, 5, 4, 5, 6, 7}; // Create an integer array and preload.\n\nbyte index;\n\nvoid setup() {\n\n    // initialize Ports B and C pins 0-5 as outputs.\n\n    DDRB = 0b00111111;\n\n    DDRC = 0b00111111;\n\n    PORTB = 0; // both ports start from zero\n\n    PORTC = 0;\n}\n\n// the loop function runs over and over again forever\n\nvoid loop() {\n\n    total = 0;\n\n    for (index = 0; index &lt; 7; index++) {\n\n        PORTC = numbers[index]; // The LEDs on Port C show the current array value.\n\n        total = total + numbers[index];\n\n        PORTB = total; // The LEDs on Port B show the running total.\n\n        delay(1000); // A one second delay.\n    }\n\n    PORTC = total; // Finally, the LEDs on Port C show the total of all the digits.\n\n    delay(2000); // A two second delay,then start all over again.\n}\n\n\n\nView or download code from GitHub Gist arrays.ino.\n\n\nWokwi simulation of program using an array\nYou can run a wokwi simulation of this circuit which was created by EEE project student Yousef Alsayegh (class of 2024-2025). The link is Lab 4: Program using an array and it uses the code from Listing 24.1. You can copy and edit this to create your own simulation of the assessed program with two arrays.\nIf you do, it would be useful to provide links to the simulations in your lab diary.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Experiment 4: Arrays</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html",
    "href": "labs/lab05/index.html",
    "title": "Experiment 5: LCD Display Panel",
    "section": "",
    "text": "Introduction\nExperiment 5 introduces two new concepts. A new piece of hardware, the alphanumeric liquid crystal display, and a new software structure, the library.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#alphanumeric-display-module",
    "href": "labs/lab05/index.html#alphanumeric-display-module",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Alphanumeric Display module",
    "text": "Alphanumeric Display module\nYou will be given an Alphanumeric Display module. This module can display two lines of 16 characters, using any characters in the ASCII standard list plus several special characters and up to eight user-defined characters. The interface to the display module is straightforward. Characters are written directly to the display and appear at the cursor position. Command characters can be sent which set the mode of operation of the display and allow the cursor to be moved around.\nDirect information on this module can be obtained from the Farnell website, part number 3759026. Displays of this type are all based on a complex integrated circuit produced by Hitachi, part number HD 44780.\nOne complication of using the alphanumeric display module is the small number of input-output pins on the Arduino Nano. A special mode of operation is employed, in which eight-bit data bytes are transferred as two, four-bit “nibbles”. A demonstration program that is available to you shows you how numeric values and character strings can be displayed.\nA copy of the data sheet for the display and a list of ASCII characters] can be found on Canvas.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#refer-back",
    "href": "labs/lab05/index.html#refer-back",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Pinout of the Alphanumeric Display module",
    "text": "Pinout of the Alphanumeric Display module\n\n\n\n\n\n\nFigure 25.1: LCD Display Panel and its pinout.\n\n\n\nThere are 18 pins arranged in a straight line, which allows the module to be plugged into a standard breadboard. The pins are grouped as eight for data, three for control, and three for power and contrast. A further four pins (pins 15 to 18) are used to illuminate the RGB “back light”. The functions of the pins are as follows:\nPin 1: Ground/Zero Volts\nPin 2: Supply positive, typically 5 V.\nPin 3: Contrast pin. Connected to a potentiometer to set the display contrast.\nPin 4: Register Select: an address line, selecting either command or data.\nPin 5: Read/Write: logic “0” for writes, logic “1” for reads.\nPin 6: Enable: writes a command or data to the display.\nPins 7 to 14: Data pins D0 to D7 respectively.\nPin 15: +5 V +5V connection for backlight.\nPins 16 to 18: zero volts for backlights red, green, blue respectively.\nThe 22\\(\\Omega\\) resistor shown in the diagram is a safety feature designed to prevent damage to the Arduino nano should the potentiometers be wired-up incorrectly. It ensures that if the supply is shorted to ground by mistake, there will be insufficient current to damage the microcontroller or the display.\nOnce the sample program has been uploaded and the LCD panel is shown to be working, the resistor can be replaced by a wire link.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#library-for-lcd",
    "href": "labs/lab05/index.html#library-for-lcd",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Library for LCD",
    "text": "Library for LCD\nMany devices such as the LCD require some complex software. A library, in this context, refers to additional code which is linked into the main program using “#include” and is accessed using specific commands. In this case, the LCD library is included as follows:\n#include &lt;LiquidCrystal.h&gt;\nSome libraries, such as the SPI and IIC libraries, are present in the standard version of the Arduino IDE. Other libraries must be added using “Tools/Manage Libraries” from within the Arduino IDE.\nHere are some examples of the extra commands that the library contains:\nlcd.setCursor(0, 1);\nThis command moves the cursor of the LCD to the start of the second line of the display.\nlcd.print(\"hello, world!\");\nIn this case, the alphanumeric string, variables, or arithmetic expression contained within the brackets is printed at the current cursor position.\nThe best way to understand how the LCD hardware and software work, is to build the circuit that follows on plug-in breadboard and to try the example programin Listing 25.1.\n\n\n\n\n\n\nFigure 25.2: Demonstration Circuit on Plug-in Breadboard.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#functions-of-the-demonstration-program",
    "href": "labs/lab05/index.html#functions-of-the-demonstration-program",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Functions of the Demonstration Program",
    "text": "Functions of the Demonstration Program\nAs explained previously, the LCD module is connected in “4-bit mode”, to minimise the number of connections to the Arduino Nano processor. In addition to the 4 data bits, there are two command signals, Register Select (RS) and Enable (E). These are the absolute minimum number of connections between the LCD and the processor. An additional command signal, Read/Write, (R/W) is connected permanently to logic “0”.\nThere are two potentiometers on the demonstration board. One sets the contrast of the LCD, which is necessary to adjust the correct balance between the illuminated and dark pixels. The other potentiometer sets the voltage on analogue input A7.\nTwo push buttons are provided, connected to digital inputs D10 and D11. Note the use of pinMode in setup(), which turns on the pull-up resistors associated with inputs D10 and D11.\nCopy the text of the demonstration program into a new Arduino sketch, and compile and upload in the usual way. When the program is running, it should display the message “hello world!” on the first line. On the second line, the first few characters are a count in seconds since the board was reset. The remainder of the second line shows the message “ADC = xxxx”, where “xxxx” represents a number between 0 and 1023, as determined by the setting of the potentiometer. Pressing the push buttons should result in the characters “R” or “L” being displayed near the end of the first line of the display.\nIf the range of the ADC is for not to be in the range 0 to 1023 (it is typically limited to around 940), then replace the 22\\(\\Omega\\) resistor by a wire link as noted earlier.\nThe example code provides examples of how to set the display and write messages and variables. The example code can form the basis of the exercise that follows.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#task-for-experiment-5",
    "href": "labs/lab05/index.html#task-for-experiment-5",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Task for Experiment 5",
    "text": "Task for Experiment 5\nThe exercise for this experiment is to configure the demonstration board as a bar graph display, similar to the exercise in Experiment 3. But in this new exercise, the bar graph is not a line of LEDs, it is the top line of the LCD. There are 16 character positions, so that each “block” of the bar graph will correspond to 64 values from the ADC (which is 10 bits, so there are 1024 possible values).\nHere is the required display. Retain the line “ADC =” followed by the ADC value displayed on the second line, this will be useful when testing your program.\nADC value = 0;        Display = \"                 \"; // all spaces\nADC value = 1-63;     Display = \"#                \"; // only first block)\nADC value = 64-127;   Display = \"##               \"; // first two blocks)\nand so on until:\nADC value = 1018-1023; Display = \"#################\"; // all 16 blocks\nThe “#” character is only here as an example. A more suitable character is available on the LCD, which corresponds to ASCII code 255 and appears as a rectangle of 7 by 5 pixels. It can be printed as follows:\nlcd.write(byte(255));\nThere are a number of ways to achieve this programme. One would be to “trap out” the zero value, and print a line of 16 space characters, then divide the ADC value by 64 and use this as an index in a character array.\nAn alternative would be to write a program loop which decrements the scaled ADC value and printing “#” until the result is zero.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#assessment-of-experiment-5",
    "href": "labs/lab05/index.html#assessment-of-experiment-5",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Assessment of Experiment 5",
    "text": "Assessment of Experiment 5\nAs with previous exercises, the plug-in breadboard should be photographed with your student card and added to your laboratory diary. A listing of your program should be included, with plenty of comments. A program without comments is of only limited value, as nobody else can follow it!",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#code-listing",
    "href": "labs/lab05/index.html#code-listing",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Code Listing",
    "text": "Code Listing\n\nLCD Panel Demonstration Program.\n\n\n\nListing 25.1: LCD Panel Demonstration Program\n\n\n/*\n  LiquidCrystal Library - Hello World\n\n  Demonstrates the use a 16x2 LCD display.  The LiquidCrystal\n  library works with all LCD displays that are compatible with the\n  Hitachi HD44780 driver. There are many of them out there, and you\n  can usually tell them by the 16-pin interface.\n\n  This sketch prints \"Hello World!\" to the LCD\n  and shows the time and the value of analogue input A7\n\n  The circuit:\n   LCD RS pin to digital pin 8\n   LCD Enable pin to digital pin 9\n   LCD D4 pin to digital pin 4\n   LCD D5 pin to digital pin 5\n   LCD D6 pin to digital pin 6\n   LCD D7 pin to digital pin 7\n   LCD R/W pin to ground\n   LCD VSS pin to ground\n   LCD VCC pin to 5V\n   10K resistor:\n   ends to +5V and ground\n   wiper to LCD VO pin (pin 3)\n   analogue input to Nano A7\n\n  Library originally added 18 Apr 2008\n  by David A. Mellis\n  library modified 5 Jul 2009\n  by Limor Fried (http://www.ladyada.net)\n  example added 9 Jul 2009\n  by Tom Igoe\n  modified 22 Nov 2010\n  by Tom Igoe\n  modified 7 Nov 2016\n  by Arturo Guadalupi\n  this sketch modified 24th Nov 2021\n  by Timothy Davies\n\n\n*/\n\n// include the library code:\n#include &lt;LiquidCrystal.h&gt;\n\n// initialize the library by associating any needed LCD interface pin\n// with the arduino pin number it is connected to\nconst int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\n// define the left and right push buttons\nconst int left = 11, right = 10;\n\nvoid setup() {\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n\n// Print a message to the LCD.\n  lcd.print(\"hello, world!\");\n\n  pinMode(left, INPUT_PULLUP);\n  pinMode(right, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0):\n  lcd.setCursor(0, 1);\n\n// print the number of seconds since reset:\n  lcd.print(millis() / 1000);\n\n  //move the cursor to the middle of the second line\n  lcd.setCursor(6, 1);\n  \n  //print the message with extra spaces to blank previous analogue data\n  lcd.print(\"ADC =     \");\n  \n  //move the cursor to the printing position for the analogue data\n  lcd.setCursor(12, 1);\n  \n  //print the value of analogue input A7 as 0 to 1023\n  lcd.print(analogRead(7));\n\n  if (digitalRead(left) == 0)\n  { \n    lcd.setCursor(14, 0);\n    lcd.print(\"L\");\n  }\n  else if (digitalRead(right) == 0)\n  { \n    lcd.setCursor(14, 0);\n    lcd.print(\" R\");\n  }\n  else {\n    lcd.setCursor(14, 0);\n    lcd.print(\"  \");\n  }\n  delay(100);\n}\n\n\n\nView and download the code from GitHub gist lcd_panel.ino.\n\n\nWokwi simulation of program using the LCD panel\nYou can run a wokwi simulation of this circuit which was created by EEE project student Yousef Alsayegh (class of 2024-2025). The link is Lab 5: LCD Panel Demonstration Program and it uses the code from Listing 25.1. You can copy and edit this to create your own simulation of the assessed program.\nIf you do, it would be useful to provide links to the simulations in your lab diary.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "labs/lab05/index.html#photograph-of-prototype-board-with-lcd-panel-display",
    "href": "labs/lab05/index.html#photograph-of-prototype-board-with-lcd-panel-display",
    "title": "Experiment 5: LCD Display Panel",
    "section": "Photograph of Prototype Board with LCD Panel Display",
    "text": "Photograph of Prototype Board with LCD Panel Display\nThe following photograph (Figure 25.3) has been provided by Dr Davies who created this experiment.\n\n\n\n\n\n\nFigure 25.3: Photograph of the Arduino Nano and LCD Display Panel with example program running.",
    "crumbs": [
      "Microcontroller Programming Laboratory",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Experiment 5: LCD Display Panel</span>"
    ]
  },
  {
    "objectID": "projects/voltmeter.html",
    "href": "projects/voltmeter.html",
    "title": "Voltmeter",
    "section": "",
    "text": "Technical Information\nHere is a video of Dr. Davies explaining how to begin the Voltmeter Mini-Project\nInitial calibration of voltmeter:\nAssume \\(V_\\mathrm{ref} = 5\\)V.\nLet us have a resistive network which divides \\(V_\\mathrm{in}\\) by four, so 20 V in becomes 5 V after the network.\nIn order to display the voltage as a meaningful number, and remembering that the maximum input to a 10 bit ADC produces a digital number of 1023, let us divide by 1024 and multiply by 20, using floating point numbers.\n\\[\\frac{V_\\mathrm{in}}{1024}\\times 20\\]\nThis resulted in reading of \\(7.388\\) for an input of \\(7.06\\) which was about 6% in error.\nThe value of \\(V_\\mathrm{ref}\\) was measured using a voltmeter, and found to be \\(4.73\\)V, not 5V. So the program was modified to multiply by \\(18.92\\) and divide by \\(1023\\). This resulted in an error of about 1%, which is much better!\nThe demo code which accounts for these adjustments follows:\nView and download the code from GitHub gist voltmenter.ino.",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Voltmeter</span>"
    ]
  },
  {
    "objectID": "projects/voltmeter.html#technical-information",
    "href": "projects/voltmeter.html#technical-information",
    "title": "Voltmeter",
    "section": "",
    "text": "/*\n  LiquidCrystal Library - Hello World\n\n  Demonstrates the use a 16x2 LCD display.  The LiquidCrystal\n  library works with all LCD displays that are compatible with the\n  Hitachi HD44780 driver. There are many of them out there, and you\n  can usually tell them by the 16-pin interface.\n\n  This sketch prints \"Hello World!\" to the LCD\n  and shows the time and the value of analogue input A7\n\n  The circuit:\n   LCD RS pin to digital pin 8\n   LCD Enable pin to digital pin 9\n   LCD D4 pin to digital pin 4\n   LCD D5 pin to digital pin 5\n   LCD D6 pin to digital pin 6\n   LCD D7 pin to digital pin 7\n   LCD R/W pin to ground\n   LCD VSS pin to ground\n   LCD VCC pin to 5V\n   10K resistor:\n   ends to +5V and ground\n   wiper to LCD VO pin (pin 3)\n   analogue input to Nano A7\n\n  Library originally added 18 Apr 2008\n  by David A. Mellis\n  library modified 5 Jul 2009\n  by Limor Fried (http://www.ladyada.net)\n  example added 9 Jul 2009\n  by Tom Igoe\n  modified 22 Nov 2010\n  by Tom Igoe\n  modified 7 Nov 2016\n  by Arturo Guadalupi\n  this sketch modified 24th Nov 2021\n  by Timothy Davies\n\n\n*/\n\n// include the library code:\n#include &lt;LiquidCrystal.h&gt;\n\n// initialize the library by associating any needed LCD interface pin\n// with the arduino pin number it is connected to\nconst int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\n// define the left and right push buttons\nconst int left = 11, right = 10;\n\nfloat ADC_READING = 0;\n\nvoid setup() {\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n\n// Print a message to the LCD.\n  lcd.print(\"Voltmeter demo\");\n\n  pinMode(left, INPUT_PULLUP);\n  pinMode(right, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0):\n  lcd.setCursor(0, 1);\n\n  // print the number of seconds since reset:\n  lcd.print(millis() / 1000);\n\n  //move the cursor to the middle of the second line\n  lcd.setCursor(4, 1);\n  \n  //print the message with extra spaces to blank previous analogue data\n  lcd.print(\"Vin =     \");\n  \n  //move the cursor to the printing position for the analogue data\n  lcd.setCursor(10, 1);\n  \n  // First attempt at calibration:\n  // The analogue input gives a number 0 to 1023\n  // Let us multiply by 20 and divide by 1024 to\n  // give us a number scaled 0 to 20 V instead\n\n  // Second attempt at calibration:\n  // Let us multiply by (4.73 times 4) instead of 20,\n  // And divide by 1024.\n\n  ADC_READING = analogRead(7);\n  ADC_READING = ADC_READING*18.92; // (4*4.73)\n  ADC_READING = ADC_READING/1023;\n  lcd.print(ADC_READING);\n\n  if (digitalRead(left) == 0)\n  { \n    lcd.setCursor(14, 0);\n    lcd.print(\"L\");\n  }\n  else if (digitalRead(right) == 0)\n  { \n    lcd.setCursor(14, 0);\n    lcd.print(\" R\");\n  }\n  else {\n    lcd.setCursor(14, 0);\n    lcd.print(\"  \");\n  }\n  delay(100);\n}",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Voltmeter</span>"
    ]
  },
  {
    "objectID": "projects/voltmeter.html#sec-bipolar-voltage-measurement",
    "href": "projects/voltmeter.html#sec-bipolar-voltage-measurement",
    "title": "Voltmeter",
    "section": "Bipolar Voltage Measurement",
    "text": "Bipolar Voltage Measurement\nHere is some additional information for students who have chosen this mini-project.\nWhat follows is a short video on how to measure and display bipolar (plus and minus) voltages.\n\n\nSome stills from the video:\n\n\n\n\n\n\nFigure 26.1: Measuring a bipolar voltage source with an ADC\n\n\n\n\n\nRange switching\n\n\n\nPrototype bipolar voltage management\n\nCode used in this demonstration:\n/*\n  LiquidCrystal Library - Hello World\n\n  Demonstrates the use a 16x2 LCD display.  The LiquidCrystal\n  library works with all LCD displays that are compatible with the\n  Hitachi HD44780 driver. There are many of them out there, and you\n  can usually tell them by the 16-pin interface.\n\n  This sketch prints \"Hello World!\" to the LCD\n  and shows the time and the value of analogue input A7\n\n  The circuit:\n   LCD RS pin to digital pin 8\n   LCD Enable pin to digital pin 9\n   LCD D4 pin to digital pin 4\n   LCD D5 pin to digital pin 5\n   LCD D6 pin to digital pin 6\n   LCD D7 pin to digital pin 7\n   LCD R/W pin to ground\n   LCD VSS pin to ground\n   LCD VCC pin to 5V\n   10K resistor:\n   ends to +5V and ground\n   wiper to LCD VO pin (pin 3)\n   analogue input to Nano A7\n\n  Library originally added 18 Apr 2008\n  by David A. Mellis\n  library modified 5 Jul 2009\n  by Limor Fried (http://www.ladyada.net)\n  example added 9 Jul 2009\n  by Tom Igoe\n  modified 22 Nov 2010\n  by Tom Igoe\n  modified 7 Nov 2016\n  by Arturo Guadalupi\n  this sketch modified 24th Nov 2021\n  by Timothy Davies\n\n\n*/\n\n// include the library code:\n#include &lt;LiquidCrystal.h&gt;\n\n// initialize the library by associating any needed LCD interface pin\n// with the arduino pin number it is connected to\nconst int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\n// define the left and right push buttons\nconst int left = 11, right = 10;\n\nfloat ADC_READING = 0;\n\nvoid setup() {\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n\n  // Print a message to the LCD.\n  lcd.print(\"Voltmeter demo\");\n\n  pinMode(left, INPUT_PULLUP);\n  pinMode(right, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0):\n  lcd.setCursor(0, 1);\n\n  // print the number of seconds since reset:\n  lcd.print(millis() / 1000);\n\n  //move the cursor to the middle of the second line\n  lcd.setCursor(4, 1);\n\n  //print the message with extra spaces to blank previous analogue data\n  lcd.print(\"Vin =      \");\n\n  //move the cursor to the printing position for the analogue data\n  lcd.setCursor(10, 1);\n\n  // Calibration:\n  // Let us multiply by (4.73 times 4) instead of 20,\n  // And divide by 1024.\n\n  ADC_READING = analogRead(7) - analogRead(6);\n  //ADC_READING = ADC_READING*18.92;\n  ADC_READING = ADC_READING * 18.71;\n  ADC_READING = ADC_READING / 1023;\n  if (ADC_READING &gt;= 0) {\n    lcd.print(\" \");\n  }\n  lcd.print(ADC_READING);\n\n  if (digitalRead(left) == 0) {\n    lcd.setCursor(14, 0);\n    lcd.print(\"L\");\n  } else if (digitalRead(right) == 0) {\n    lcd.setCursor(14, 0);\n    lcd.print(\" R\");\n  } else {\n    lcd.setCursor(14, 0);\n    lcd.print(\"  \");\n  }\n  delay(100);\n}",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Voltmeter</span>"
    ]
  },
  {
    "objectID": "projects/range_finder.html",
    "href": "projects/range_finder.html",
    "title": "Ultrasonic Range Finder",
    "section": "",
    "text": "Technical Information\nHere are some thoughts about the ultrasonic range finder, and a brief piece of code which is FAR from ideal!\nHere is a picture of the Experiment 5 breadboard with the ultrasonic module connected, and showing a time interval of about 500μs for the echo. That corresponds to about 160 mm, divided by two for out and back, which is 80 mm. Look at the ruler; the distance from the cardboard box and the back of the sensor is about 80 mm, so we are not far off the correct measurement.\nNow look at the waveforms on the oscilloscope.\nYou will see that the “trig” pulse is very narrow, about 5 μs, which is plenty. The echo pulse is about 500 μs, corresponding to the number on the LCD.\nThe code to produce the above waveform follows. It is for GUIDANCE ONLY, as it has no averaging or scaling, and it “locks up” if no echo is received.\nTrig is on A0/digital pin 14, and Echo is on A1/digital pin 15.\nView and download the code from GitHub gist range_finder.ino.",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ultrasonic Range Finder</span>"
    ]
  },
  {
    "objectID": "projects/range_finder.html#technical-information",
    "href": "projects/range_finder.html#technical-information",
    "title": "Ultrasonic Range Finder",
    "section": "",
    "text": "/*\n  LiquidCrystal Library - Hello World\n\n Demonstrates the use a 16x2 LCD display.  The LiquidCrystal\n library works with all LCD displays that are compatible with the\n Hitachi HD44780 driver. There are many of them out there, and you\n can usually tell them by the 16-pin interface.\n\n This sketch prints \"Hello World!\" to the LCD\n and shows the time and the value of analogue input A7\n\n  The circuit:\n * LCD RS pin to digital pin 8\n * LCD Enable pin to digital pin 9\n * LCD D4 pin to digital pin 4\n * LCD D5 pin to digital pin 5\n * LCD D6 pin to digital pin 6\n * LCD D7 pin to digital pin 7\n * LCD R/W pin to ground\n * LCD VSS pin to ground\n * LCD VCC pin to 5V\n * 10K resistor:\n * ends to +5V and ground\n * wiper to LCD VO pin (pin 3)\n * analogue input to Nano A7\n\n Library originally added 18 Apr 2008\n by David A. Mellis\n library modified 5 Jul 2009\n by Limor Fried (http://www.ladyada.net)\n example added 9 Jul 2009\n by Tom Igoe\n modified 22 Nov 2010\n by Tom Igoe\n modified 7 Nov 2016\n by Arturo Guadalupi\n this sketch modified 24th Nov 2021\n by Timothy Davies\n\n \n*/\n\n// include the library code:\n#include &lt;LiquidCrystal.h&gt;\n\n#define trig 14\n#define echo 15\n\n// initialize the library by associating any needed LCD interface pin\n// with the arduino pin number it is connected to\nconst int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\n// define the left and right push buttons\nconst int left = 11, right = 10;\n\n\nunsigned int starttime=0; // 0 - 65,355\nunsigned int stoptime=0;\nunsigned int distance=0;\n\n\nvoid setup() \n{\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n\n  pinMode (trig,OUTPUT);\n     \n}\n\nvoid loop() \n{\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0):\n  lcd.setCursor(0, 1);\n  \n  digitalWrite(trig,1); //send out the trig pulse\n  digitalWrite(trig,0);\n\n  while (digitalRead(echo)==0) {}  //wait for echo to go high\n \n  starttime = micros();\n\n  while (digitalRead(echo)!=0) {} wait for echo to go low again\n  \n  stoptime = micros();\n\n  distance = stoptime-starttime;\n  lcd.print(\"         \"); //blank previous result\n  lcd.setCursor(0, 1);\n  lcd.print(distance);\n  \n  delay (100);\n}",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Ultrasonic Range Finder</span>"
    ]
  },
  {
    "objectID": "projects/clock_timer.html",
    "href": "projects/clock_timer.html",
    "title": "Clock Time",
    "section": "",
    "text": "Getting Started with the Time Clock Project",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Clock Time</span>"
    ]
  },
  {
    "objectID": "projects/clock_timer.html#sec-getting-started-with-the-time-clock-project",
    "href": "projects/clock_timer.html#sec-getting-started-with-the-time-clock-project",
    "title": "Clock Time",
    "section": "",
    "text": "Starter code\nThe starter code starts the clock at an arbitrary time and then uses the millis() function to keep the clock time synchronised to the initial epoch time. I have used the Serial monitor for the output and you will need to change the code to use the LCD panel.\nThe Serial monitor is still useful during development and for debugging though!\nYour first task will be to set the initial time in the setup() function before you press the button on pin 2 or Port D to set the clock time. After that, the clock time should keep reasonable time based on the epoch time stored in epoch_time.\n// Define times in millis as useful constants\n#define MILLIS_PER_SECOND 1000\n#define MILLIS_PER_MINUTE 60 * MILLIS_PER_SECOND\n#define MILLIS_PER_HOUR 60 * MILLIS_PER_MINUTE\n#define MILLIS_PER_DAY 24 * MILLIS_PER_HOUR\n\nunsigned long epoch_time, initial_time, clock_time;\nunsigned int days, hours, minutes, seconds, milli_seconds;\n\n// The setup function runs once when you press reset or power the board\n// Use it to set the time and record the realtime offset\nvoid setup() {\n\n  Serial.begin(9600);\n  Serial.println(\"Set time then press button when ready\");\n\n  pinMode(2, INPUT_PULLUP);  // Make bit 2 of Port D an input\n\n  // Initial time is arbitrarily set to 12:15:35:101\n  hours = 12;\n  minutes = 15;\n  seconds = 35;\n  milli_seconds = 101;\n  initial_time = hours * MILLIS_PER_HOUR + minutes * MILLIS_PER_MINUTE + seconds * MILLIS_PER_SECOND + milli_seconds;\n  Serial.print(\"Epoch offset: \");\n  Serial.println(initial_time);\n  \n  /* Write code to accept values entered from clock diaplay \n     and use button press as a go signal */\n  while ((PIND & 0b00000100) != 0) {\n    Serial.println(\"Waiting ...\");\n    break;\n  }\n  Serial.println(\"Go ...\");\n  epoch_time = millis();\n  Serial.print(\"Epoch time: \");\n  Serial.println(epoch_time);\n}\n\n// the loop function runs over and over again forever\n\nvoid loop() {\n\n  clock_time = millis() + initial_time;\n  Serial.print(\"Clock time: \");\n  Serial.println(clock_time);\n\n  // Because of the delay, the clock display will update each second approximately.\n  // There could be some drift here - so it's best to compute the time rather\n  // than relying on the instructions given to update hh:mm:ss.\n  // As supplied, the clock will go to 00:00:00 at midnight and the epoch will reset.\n  // You can include days but note that millis() resets every 79 days or so.\n  delay(1000);  // reduce this delay for faster counting\n  seconds++;\n  if (seconds &gt; 59) {\n    seconds = 0;\n    minutes++;\n    if (minutes &gt; 59) {\n      minutes = 0;\n      hours++;\n      if (hours &gt; 23) {\n        hours = 0;\n        // days++;\n        // reset epoch offset at midnight unless you want to track days too\n        initial_time = millis();\n      }\n    }\n  }\n  Serial.print(hours);\n  Serial.print(\":\");\n  Serial.print(minutes);\n  Serial.print(\":\");\n  Serial.print(seconds);\n  Serial.println(\" \");\n}\nView and download the code from GitHub gist clock.ino.\n\n\nTips\nYour program will benefit from the use of functions, e.g. to display current time you could write a function:\nvoid display_time(int hours, int minutes, int hours) {\n  Serial.print(hours);\n  Serial.print(\":\");\n  Serial.print(minutes);\n  Serial.print(\":\");\n  Serial.print(seconds);\n  Serial.println(\" \");\n}\nWhen you want to display the time you will just call\ndisplay_time(hours, minutes, seconds);\nAs you extend the clock, you will occasionally need to leave the main loop, e.g. to set an alarm. This means that the loop will not be updating the time while you are doing something else.\nYou will therefore need a function to compute the current clock time in elapsed hours, minutes and seconds from clock_time. How to do this is left as an exercise, but the MATLAB code clocks.mlx which you will find in my the shared MATLAB drive folder eg-151 may help help you to understand how you might do the computations needed.\nNote that in MATLAB mod(11,2) is equivalent to the C code:\n11 % 2; // = 1: remainder of 11/2\nand floor(11,2) is equivalent to to the C code:\n11 / 2; // = 5: integer division gives 5.5 rounded down to nearest integer\nYou will need both integer division and modulo division to convert a time defined in milliseconds elapsed into actual clock time in hours:minutes:seconds.",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Clock Time</span>"
    ]
  },
  {
    "objectID": "projects/weather_station.html",
    "href": "projects/weather_station.html",
    "title": "Weather Station",
    "section": "",
    "text": "Weather Station Demonstration\nWatch Dr. Davies explaining how to approach the Weather Station mini-project.\nThe video lasts 17 minutes.\nHere is a sketch of the op-amp circuit.\nAnd here are details of the LM324 op-amp and LM35 temperature sensor.\nHere are some photos of the advanced demonstration program running.\nNote that the wind direction has been scaled to give a number 0 to 359 instead of 0 to 1023.\nIn this photo, the “raw” temperature data has been scaled to give degrees Celsius.\nHere is a listing of the basic programme, which presents the “raw” data 0 to 1023.\nView and download the code from GitHub gist weather.ino.",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Weather Station</span>"
    ]
  },
  {
    "objectID": "projects/weather_station.html#sec-weather-station-demonstration",
    "href": "projects/weather_station.html#sec-weather-station-demonstration",
    "title": "Weather Station",
    "section": "",
    "text": "/*\n  LiquidCrystal Library - Hello World\n\n Demonstrates the use a 16x2 LCD display.  The LiquidCrystal\n library works with all LCD displays that are compatible with the\n Hitachi HD44780 driver. There are many of them out there, and you\n can usually tell them by the 16-pin interface.\n\n  The circuit:\n * LCD RS pin to digital pin 12\n * LCD Enable pin to digital pin 11\n * LCD D4 pin to digital pin 5\n * LCD D5 pin to digital pin 4\n * LCD D6 pin to digital pin 3\n * LCD D7 pin to digital pin 2\n * LCD R/W pin to ground\n * LCD VSS pin to ground\n * LCD VCC pin to 5V\n * 10K resistor:\n * ends to +5V and ground\n * wiper to LCD VO pin (pin 3)\n\n Library originally added 18 Apr 2008\n by David A. Mellis\n library modified 5 Jul 2009\n by Limor Fried (http://www.ladyada.net)\n example added 9 Jul 2009\n by Tom Igoe\n modified 22 Nov 2010\n by Tom Igoe\n modified 7 Nov 2016\n by Arturo Guadalupi\n\n This example code is in the public domain.\n\n http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld\n\n*/\n\n// include the library code:\n#include &lt;LiquidCrystal.h&gt;\n\n// initialize the library by associating any needed LCD interface pin\n// with the arduino pin number it is connected to\nconst int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\nvoid setup() {\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  // Print a message to the LCD.\n  lcd.print(\"Weather Station\");\n  delay (1000);\n}\n\nvoid loop() {\n  lcd.clear();\n  winddir();\n  windspd();\n  delay (1500);\n  lcd.clear();\n  temp1();\n  temp2();\n  delay(1500);\n}\n\nvoid winddir(void)\n{\n  lcd.setCursor(0, 0);\n  lcd.print(\"Wind Dir =      \");\n  lcd.setCursor(11, 0);\n  lcd.print(analogRead(6));\n}\n\nvoid windspd(void)\n{\n  lcd.setCursor(0, 1);\n  lcd.print(\"Wind Spd =      \");\n  lcd.setCursor(11, 1);\n  lcd.print(analogRead(7));\n}\n\nvoid temp1(void)\n{\n  lcd.setCursor(0, 0);\n  lcd.print(\"Temp 1 =      \");\n  lcd.setCursor(9, 0);\n  lcd.print(analogRead(5));\n}\n\nvoid temp2(void)\n{\n  lcd.setCursor(0, 1);\n  lcd.print(\"Temp 2 =      \");\n  lcd.setCursor(9, 1);\n  lcd.print(analogRead(4));\n}",
    "crumbs": [
      "Mini Projects",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Weather Station</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Anonymous. 2024. “LibGuides:\nVancouver Referencing Guide (Online):\nHome — Libguides.swansea.ac.uk.” Swansea University:\nhttps://libguides.swansea.ac.uk/Vancouver.\n\n\nAtmel. 2015. Datasheet: ATmega328p: 8-Bit AVR Microntroller with 32K\nBytes in-System Programming Flash (version 7810D–AVR–01/15).\nMicrochip; \n                  https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf\n.\n\n\n———. 2020. AVR(r) Instruction Set Manual (version DS40002198A).\nMicrochip; \n                  https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/ReferenceManuals/AVR-InstructionSet-Manual-DS40002198.pdf\n.\n\n\nHyde, Randall. 2010. 2nd ed. No Starch Press.\n\n\nKerningham, Brian, and Dennis Ritchie. 1978. The C\nProgramming Language. 1st ed. Prentice; Hall.\n\n\n“The Accreditation of Higher Education Programmes (AHEP).”\n2020. The Engineering Council; \n                  https://www.engc.org.uk/media/3464/ahep-fourth-edition.pdf.\n2020.\n\n\n\n\n\nCopyright © 2021-2024 Swansea University. All rights reserved.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html",
    "href": "appendix/appendix_a.html",
    "title": "Appendix A — Other Data Representations",
    "section": "",
    "text": "Contents",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#contents",
    "href": "appendix/appendix_a.html#contents",
    "title": "Appendix A — Other Data Representations",
    "section": "",
    "text": "Section A.1: Twos Complement\nSection A.2: Binary Coded Decimal\nSection A.3: Binary Fractions\nSection A.4: ASCII",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#sec-appendixa-2scomp",
    "href": "appendix/appendix_a.html#sec-appendixa-2scomp",
    "title": "Appendix A — Other Data Representations",
    "section": "A.1 Twos Compliment",
    "text": "A.1 Twos Compliment\n\nA.1.1 Negative Numbers\nUp until now, we have only considered positive or unsigned values, how can we handle negative numbers?\nAn unsigned number itself contains no indication whether it is negative or positive.\nA number is said to be signed when the most significant bit (MSB) is used to indicate the sign of the number ‘0’ being used if the number is positive and ‘1’ being used if the number is negative.\nWhilst this technique can be used to represent a negative number it is not a practical approach.\n\nExample\nTry the following simple sum \\(2 + -1 = ?\\)\nStart with the two numbers\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 010 & 2\\\\\n\\mathrm{Augend} & 001 & 1\\\\\n\\hline\n\\mathrm{Sum} & &\n\\end{array}\\]\nChamge the MSB of number 2 to 1 to indicate that it is negative\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 0010 & 2 \\\\\n\\mathrm{Augend} & 1001 & -1 \\\\\n\\hline\n\\mathrm{Sum} & &\n\\end{array}\\]\nNow add the addend to the augend\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 0010 & 2 \\\\\n\\mathrm{Augend} & 1001 & -1 \\\\\n\\hline\n\\mathrm{Sum} & 1011 & -3\n\\end{array}\\]\nThe answer comes out as \\(-3\\) which is clearly wrong. We must use a different approach.\n\n\n\nA.1.2 Twos Complement\nA more useful way to represent negative numbers is to use the twos complement method.\nA binary number has two complements - a ones complement and a twos complement.\n\nTo get the ones complement, change all 1’s of the unsigned number to 0’s and all 0’s to 1’s, then\nTo get the twos complement add 1 to the ones complement.\n\nFigure A.1 shows the twos complement numbers for all the four bit integers.\n\n\n\n\n\n\nFigure A.1: Twos complement\n\n\n\n\nExample\nConsider the representation of the decimal number \\(-1\\)\n\\[\\begin{array}{lr}\n\\mathrm{Unsigned\\ binary\\ number} & 0001\\\\\n\\mathrm{Ones\\ complement} & 1110\\\\\n\\mathrm{Add\\ one} & 1\\\\\n\\hline\n\\mathrm{Signed\\ twos\\ complement}& \\mathrm{c}1111\n\\end{array}\\]\nNow try the addition with the twos complement value (\\(1111\\)) of \\(-1\\):\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 0010 & 2 \\\\\n\\mathrm{Augend} & 1111 & -1 \\\\\n\\hline\n\\mathrm{Sum} & \\mathrm{c}0001 & -3\n\\end{array}\\]\nWhen performing addition with twos complement, if the MSB is a carry bit, it is dropped.\n\n\n\nA.1.3 More examples\nUse the twos complement method to represent the decimal number \\(-27\\)\n\\[\\begin{array}{lr}\n\\mathrm{Unsigned\\ value} & 00011011 \\\\\n\\mathrm{Ones\\ complement} & 11100100 \\\\\n\\hline\n\\mathrm{Twos\\ complement} & 11100101 \\\\\n\\hline\n\\end{array}\\]\nCheck\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 00011011 & 27_{10}\\\\\n\\mathrm{Augend} & 11100101 & -27_{10}\\\\\n\\hline\n\\mathrm{Signed\\ twos\\ complement}& \\mathrm{c}00000000 & 0_{10}\n\\end{array}\\]\nUse the twos complement method to represent the decimal number \\(-84\\)\n\\[\\begin{array}{lr}\n\\mathrm{Unsigned\\ value} &  01010100 \\\\\n\\mathrm{Ones\\ complement} & 10101011 \\\\\n\\hline\n\\mathrm{Twos\\ complement} & 10101100 \\\\\n\\hline\n\\end{array}\\]\nCheck\n\\[\\begin{array}{lrr}\n\\mathrm{Addend} & 01010100 & 84_{10}\\\\\n\\mathrm{Augend} & 10101100 & -84_{10}\\\\\n\\hline\n\\mathrm{Signed\\ twos\\ complement}& \\mathrm{c}00000000 & 0_{10}\n\\end{array}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#sec-appendixa-bcd",
    "href": "appendix/appendix_a.html#sec-appendixa-bcd",
    "title": "Appendix A — Other Data Representations",
    "section": "A.2 Binary Coded Decimal (BCD)",
    "text": "A.2 Binary Coded Decimal (BCD)\nBinary Coded Decimal, also known as BCD or 8421 format is another widely used numbering system whereby each decimal digit from 0-9 is individually represented as a 4-bit binary number between 0000 and 1001.\nThe main advantage of binary coded decimal is that it allows easy conversion between decimal and binary form.\nWhere is BCD used\n\nCalculators\nDecimal display drivers\nDigital Clocks\nPC BIOS to store date and time\n\nTable A.1 shows the codes for the 10 values that are used in BCD coded representations.\n\n\n\nTable A.1: Binary Coded Decimal\n\n\n\n\n\nDecimal\nBCD Coding\n\n\n\n\n0\n0000\n\n\n1\n0001\n\n\n2\n0010\n\n\n3\n0011\n\n\n4\n0100\n\n\n5\n0101\n\n\n6\n0110\n\n\n7\n0111\n\n\n8\n1000\n\n\n9\n1001\n\n\n\n\n\n\n\nA.2.1 Examples\n\\(5_{10} ≡ 0101_\\textrm{BCD}\\)\n\\(22_{10} ≡ 0010\\, 0010_\\textrm{BCD}\\)\n\\(86_{10} ≡ 1000\\, 0110_\\textrm{BCD}\\)\n\\(2020_{10} ≡ 0010\\, 0000\\, 0010\\, 0000_\\textrm{BCD}\\)\n\n\nA.2.2 Pros and Cons of Binary Coded Decimal\n\nA.2.2.1 Pros\n\nSimple to convert between BCD and decimal values.\nSLess data loss in floating point calculations.\n\n\n\nA.2.2.2 Cons\n\nRequires more complex circuitry.\nWasteful as only uses 10 out of 16 possible 8-bit representations.\nRequires more storage than other encoding systems.\n\n\\(15_{10} = 1111_2 = 0001\\, 0101_\\textrm{BCD}\\)\n\\(255_{10} = 1111\\, 1111_2 = 0010\\, 0101\\, 0101_\\textrm{BCD}\\)\n\\(8579_{10} = 0010\\, 0001\\, 1000\\, 0011_2 = 1000\\, 0101\\, 0111\\, 1001_\\textrm{BCD}\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#sec-appendixa-binary-fractions",
    "href": "appendix/appendix_a.html#sec-appendixa-binary-fractions",
    "title": "Appendix A — Other Data Representations",
    "section": "A.3 Binary Fractions",
    "text": "A.3 Binary Fractions\n\nA.3.1 Floating Point Numbers\nWith decimal numbers a decimal point is used to separate the whole and fractional parts of a number. Recalling from {ref}week02 that we represent numbers using a weighted positional notation in which a digit’s value is relative to its position. Figure A.2 illustrates the idea:\n\n\n\n\n\n\nFigure A.2: Positional notation\n\n\n\nWe use exponentiation of negative powers of the base to represent the fractional part of a number:\n\\[14.12_{10} = \\left(1\\times 10^1\\right) + \\left(4\\times 10^0\\right) + \\left(1\\times 10^{-1}\\right) + \\left(2\\times 10^{-2}\\right)\\] \nThe idea extends to binary, octal and hexadecimal numbers:\n\\[\\begin{align*}\n0000.101_2 &= \\left(1\\times 2^{-1}\\right) + \\left(0\\times 2^{-2}\\right) + \\left(1\\times 2^{-3}\\right) \\\\\n&= \\frac{1}{2} + 0\\times \\frac{1}{4} + \\frac{1}{8}\\\\\n&= 0.5 + 0 + 0.125 = 0.625_{10}\n\\end{align*}\\]\nThe representation of octal and hexadecimal numbers is left as an exercise.\n\n\nA.3.2 Decimal Floating-Point Number Conversion\nTo convert a decimal fraction (base 10) to a new base (n) the fractional part is repeatedly multiplied by n.\n\nThe whole number part of the product gives the value at the current power.\nThe decimal part of the product is multiplied by n and repeated until the fractional part of the product is zero.\nRead the result from top to bottom.\n\n\n\nA.3.3 Limitations\nConvert \\(0.675_{10}\\) to binary\n0.675 × 2 = 1.35 1\n0.35 × 2 = 0.7 0\n0.7 × 2 = 1.4 1\n0.4 × 2 = 0.8 0\n0.8 × 2 = 1.6 1\n0.6 × 2 = 1.2 1\n0.2 × 2 = 0.4 0\n0.4 × 2 = 0.8 0\n0.8 × 2 = 1.6 1\nNote this is a recurring fraction.\n\n\nA.3.4 Reality\nModern computers use a special data format called floating point which can be used to approximate decimal numbers to a reasonable precision over a large range. However, floating point numbers need more storage (typically 32 or 64 bits per number) and special hardware to make computation with these values efficient. For microcontrollers, particularly with limited memory and 8-bit data storage, we rarely use floating point arithmetic, or fractions, and rely instead of integer representations.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#sec-appendixa-ascii",
    "href": "appendix/appendix_a.html#sec-appendixa-ascii",
    "title": "Appendix A — Other Data Representations",
    "section": "A.4 ASCII",
    "text": "A.4 ASCII\nASCII. (American Standard Code for Information Interchange) is an encoding format for text developed in the early 1960’s.\nThe original ASCII format was based on the English alphabet and encodes 128 specified characters into seven-bit binary numbers.\nNinety-five of the encoded characters are printable, including the digits 0 to 9, lowercase letters a to z, uppercase letters A to Z, space, and punctuation symbols.\nThe remaining 32 non-printing control codes for based around the standards original implementation with Teletype machines – most of these are now obsolete but some are still used including carriage return (\\r in C), line feed (\\n in C), tab (\\t in C).\nAs microprocessors evolved to 8-bit and higher the ASCII standard has also evolved to use the eighth bit allowing a further 127 characters (extended ASCII).1\nThe ANSI ASCII table for … is reproduced in Table A.2.\n\n\n\nTable A.2: ANSI ASCII Table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDec\nHex\nSymbol\nDec\nHex\nSymbol\nDec\nHex\nSymbol\nDec\nHex\nSymbol\n\n\n\n\n0\n0x00\nNull character2\n32\n0x20\nSP\n64\n0x40\n@\n96\n0x61\n`\n\n\n1\n0x01\nStart of heading\n32\n0x21\n!\n65\n0x41\nA\n96\n0x61\na\n\n\n2\n0x02\nStart of text\n34\n0x22\n\"\n66\n0x42\nB\n98\n0x62\nb\n\n\n3\n0x03\nEnd of text\n35\n0x23\n#\n67\n0x43\nC\n99\n0x63\nc\n\n\n4\n0x04\nEnd of Transmission\n36\n0x24\n$\n68\n0x44\nD\n100\n0x64\nd\n\n\n5\n0x05\nEnquiry\n37\n0x25\n%\n69\n0x45\nE\n101\n0x65\ne\n\n\n6\n0x06\nAcknowledgement\n38\n0x26\n&\n70\n0x46\nF\n102\n0x66\nf\n\n\n7\n0x07\nBell\n39\n0x27\n'\n71\n0x47\nG\n103\n0x67\ng\n\n\n8\n0x08\nBackspace\n40\n0x08\n(\n72\n0x48\nH\n104\n0x68\nh\n\n\n9\n0x09\nHorizontal tab\n41\n0x29\n)\n73\n0x49\nI\n105\n0x69\ni\n\n\n10\n0x0A\nLine feed\n42\n0x2A\n*\n74\n0x4A\nJ\n106\n0x6A\nj\n\n\n11\n0x0B\nVertical tab\n43\n0x2B\n+\n75\n0x4B\nK\n107\n0x6B\nk\n\n\n12\n0x0C\nForm feed\n44\n0x2C\n,\n76\n0x4C\nL\n108\n0x6C\nl\n\n\n13\n0x0D\nCarriage return\n45\n0x2D\n-\n77\n0x4D\nM\n109\n0x6D\nm\n\n\n14\n0x0E\nShift out\n46\n0x2E\n.\n78\n0x4E\nN\n110\n0x6E\nn\n\n\n15\n0x0F\nShift in\n47\n0x2F\n/\n79\n0x4F\nO\n111\n0x6F\no\n\n\n16\n0x10\nData link escape\n48\n0x30\n0\n80\n0x50\nP\n112\n0x70\np\n\n\n17\n0x11\nDevice control 1\n49\n0x31\n1\n81\n0x51\nQ\n113\n0x71\nq\n\n\n18\n0x02\nDevice control 2\n50\n0x32\n2\n82\n0x52\nR\n114\n0x72\nr\n\n\n19\n0x13\nDevice control 3\n51\n0x33\n3\n83\n0x53\nS\n115\n0x73\ns\n\n\n20\n0x14\nDevice control 4\n52\n0x34\n4\n84\n0x54\nT\n116\n0x74\nt\n\n\n21\n0x15\nNegative acknowledgement\n53\n0x35\n5\n85\n0x55\nU\n117\n0x75\nu\n\n\n22\n0x16\nSynchronous idle\n54\n0x36\n6\n86\n0x56\nV\n118\n0x76\nv\n\n\n23\n0x17\nEnd of transmission block\n55\n0x37\n7\n87\n0x57\nW\n119\n0x77\nw\n\n\n24\n0x18\nCancel\n56\n0x38\n8\n88\n0x58\nX\n120\n0x78\nx\n\n\n25\n0x19\nEnd of medium\n57\n0x39\n9\n89\n0x59\nY\n121\n0x79\ny\n\n\n26\n0x1A\nSubstitute\n58\n0x3A\n:\n90\n0x5A\nZ\n122\n0x7A\nz\n\n\n27\n0x1B\nEscape\n59\n0x3B\n;\n91\n0x5B\n[\n123\n0x7B\n{\n\n\n28\n0x1C\nFile separator\n60\n0x3C\n&lt;\n92\n0x5C\n\\\n124\n0x7C\n|\n\n\n29\n0x1D\nGroup separator\n61\n0x3D\n=\n93\n0x4D\n]\n125\n0x7D\n}\n\n\n30\n0x1E\nRecord separator\n62\n0x3E\n&gt;\n94\n0x5E\n^\n126\n0x7E\n~\n\n\n31\n0x1F\nUnit separator\n63\n0x3F\n?\n95\n0x5F\n_\n127\n0x7F\nDelete\n\n\n\n\n\n\nA very useful and useful reference is available as ascii-code.com. See also ASCII Code Chart.\n\nA.4.1 Example\nEncode the string “Welcome to Swansea University” in ASCII and give the binary codes that would be used to store this string in computer memory.\n\nA.4.1.1 Solution\nLook up the characters and write down the equivalent hexadecimal code. Note, null (\\0) is used to terminate the string\n'W' = \\(87_{10}\\) = 0x57 = \\(01010111_2\\)\n'e' = \\(101_{10}\\) = 0x65 = \\(01100101_2\\)\n'l' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n'c' = \\(99_{10}\\) = 0x63 = \\(01100011_2\\)\n'o' = \\(111_{10}\\) = 0x6F = \\(01101111_2\\)\n'm' = \\(109_{10}\\) = 0x6D = \\(01101101_2\\)\n'e' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n' ' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n't' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n'o' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n' ' = \\(32_{10}\\) = 0x20 = \\(00100000_2\\)\n'S' = \\(83_{10}\\) = 0x53 = \\(01010011_2\\)\n'w' = \\(119_{10}\\) = 0x77 = \\(01110111_2\\)\n'a' = \\(97_{10}\\) = 0x61 = \\(01100001_2\\)\n'n' = \\(110_{10}\\) = 0x6E = \\(01101110_2\\)\n's' = \\(115_{10}\\) = 0x73 = \\(01110011_2\\)\n'e' = \\(108_{10}\\) = 0x6C = \\(01101011_2\\)\n'a' = \\(97_{10}\\) = 0x61 = \\(01100001_2\\)\n\\0 = 0x000 = \\(00000000_2\\)\nThe final result (in hexadecimal) is\n57\n65\n6C\n63\n6F\n6D\n65\n32\n74\n6E\n32\n53\n77\n61\n6E\n73\n65\n61\n00",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/appendix_a.html#footnotes",
    "href": "appendix/appendix_a.html#footnotes",
    "title": "Appendix A — Other Data Representations",
    "section": "",
    "text": "As ASCII was only designed to represent English, extended ASCII was developed been used to extend the coding so that displays could print accented European characters, some Greek symbols used in mathematics, and some symbols that could be used to draw boxes on a simple display screen. In order to support the rest of the human languages and alphabets, and for other purposes such as Emojis, ASCII has been extended to a standard called UTF-8. This uses more bytes to represent each character and therefore greatly extends the types of texts that can be stored and manipulated inside a computer.↩︎\nthe null character (\\0 in C) is used in C to mark the end of a string.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Other Data Representations</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html",
    "href": "appendix/programming_in_c.html",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "",
    "text": "B.1 Introduction\nThis part provides a detailed worked example of writing code in C language to run on the Atmel ATmega328 microcontroller, including why each line of code is written and where any additional information comes from and how it can be found.\nThese pages start with a description of some desired functionality written in the form of a task to be completed.\nThe sections go through the thought process a programmer should follow to plan and ultimately write the software to achieve this task. The first version is focussed on using the Arduino IDE with the predefined functions such as pinMode() and digitalWrite() before looking at writing the same program in pure C.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#contents",
    "href": "appendix/programming_in_c.html#contents",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "Contents",
    "text": "Contents\n\nSection B.2: The Task\nSection B.3: Understanding the task and first thoughts\nSection B.4: Wiring up the Circuit\nSection B.5: Using the Arduino Integrated Development Environment\nSection B.6: Setting up I/O connections\nSection B.7: Detecting and reacting to a button press",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-1",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-1",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.2 The Task",
    "text": "B.2 The Task\n\nB.2.1 Project Brief\nUsing the Arduino Nano board which contains an Atmel ATMega 328 Microcontroller; write a program so that every time a push button is pressed, an analogue signal (such as the output of a sensor) is read and the value of the voltage as a proportion of the maximum voltage displayed on a bank of LEDs.\nThis task is similar to the task defined for Experiment 3: Analogue to Digital Conversion but it is tackled in a slightly different way.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-2",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-2",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.3 Understanding the task and first thoughts",
    "text": "B.3 Understanding the task and first thoughts\n\nB.3.1 Understanding the Brief\nThe first step in writing any program is ensuring you understand the task or brief, the hardware that will be involved and what the outputs/results should be.\n\n\nB.3.2 The Task\nThe program written needs to detect when a push button is pressed, at each button press the voltage from an analogue signal needs to be read. Once the signal voltage has been read, the value must be processed and the value displayed visually on a bank of LEDs.\n\n\nB.3.3 The Hardware\nIn this task, there are three pieces of external hardware involved, an analogue signal from a sensor, a push button switch and a bank of LEDs.\n\nThe analogue input – this can be created using a potentiometer connected between the supply voltage and ground with the centre tap connected to an input on the microcontroller1. For the built in ADC of the Atmel ATmega328 this is 5V.\nThe push button switch – this can be connected to ground on one side of the switch and to a microcontroller input on the other2.\nThe bank of LEDs (with current limiting resistors) – for simplicity it is easiest to use 8 LEDs connected to the 8 pins of a single port. Since each port is linked to an output register which is 8 bits wide (PORTx) this will make it simpler to program the output part of the task.\n\n\n\nB.3.4 First thoughts on Implementation\n\nB.3.4.1 Push Button\n\nThe pin that the push button will be connected to will need to be configured as an input.\nThe pull-up resistor for this pin will also need to be enabled.\n\nThis will be a digital signal with a value of 5V or HIGH when the button is not pressed and a value of 0V or LOW when the button is pressed\n\n\n\n\nB.3.4.2 Analogue Input\n\nThe pin that the analogue input is connected to will need to be one that is also connected to the ADC.\nThe pin will also need to be configured as an input.\nThe ADC registers will need to be configured as required.\n\n\n\nB.3.4.3 LEDs\n\nThe pins that the LEDs are connected to will need to be configured as outputs.\nThe default state of the LEDs should be off or LOW\nAs the task states the value shown by the LEDs should represent the value of the analogue input relative to the maximum voltage, this will be easier to Implement in software if all of the LEDs are on the same port.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-3",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-3",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.4 Wiring up the Circuit",
    "text": "B.4 Wiring up the Circuit\nReferencing the pinout of the Arduino nano in Figure B.1 below, the programmer must first identify where each of the three hardware elements will be connected, ensuring that the pins/ports meet the requirements.\n\nFor the push button sw -ltch, this will be a digital signal (on/off) so can be connected to any GPIO pin.\n\nLooking at the other hardware requirements, this should avoid the pins connected to the ADC and leave a full port of input pins for the LEDs. For this example, connection D8 of the nano board is a convenient pin to use, this is connected to PB0, i.e. Port B bit 03.\n\nFor the analogue input, this can be connected to any of the GPIO pins which is also connected to the ADC.\n\nLooking at Figure B.1, these connections are labelled A0 – A7 on the nano board. Connection A0 is connected to PC0, i.e. Port C bit 0 which is also connected to ADC[0] – ADC channel 0.4\n\nThe LEDs can be connected to any digital GPIO pin, but ideally will be 8 pins on the same port.\n\nLooking at Figure B.1 and the two pins we have used above, connections D0 – D7 can be used which corresponds to Port D bits 0-75.\n\n\nA possible assembly is illustrated in Figure B.26\n\n\n\n\n\n\nFigure B.1: Arduino Nano Pinout - Arduino Nano links.\n\n\n\n\n\n\n\n\n\nFigure B.2: The circuit assembled on breadboard",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-4",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-4",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.5 Using the Arduino Integrated Development Environment",
    "text": "B.5 Using the Arduino Integrated Development Environment\nInitially this guide will look at programming this task using the Arduino Integrated Development Environment (IDE) with the predefined functions detailed in the Arduino Language Reference.\n\nB.5.1 Step 1\nOpen the Arduino software and set up the IDE by selecting which device is being used and which communication interface it is connected to. Within the “Tools” menu option, locate the menu item “Board” and select Arduino Nano, also in the “Tools” menu select the port that the Arduino Nano is connected to (COMx) under the “Port” menu item (note the Arduino must be connected to do this)7. After setting these parameters , under the “Tools” menu the “Get Board Info” menu item can be pressed which will attempt to communicate with the Arduino board and get the board name and serial number of the USB communication chip if successful.\n\n\nB.5.2 Step 2\nWith the IDE now setup, we can begin writing the code that will be uploaded to run on the microcontroller. By default, when a new file is started in the Arduino IDE, there are two existing function blocks as shown below and in Figure B.3.\nvoid setup() {\n  // put your setup code here, to run once:\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n\n\n\n\n\n\nFigure B.3: A screenshot of the Arduino IDE when first opened showing the setup and loop functions.\n\n\n\n\nB.5.2.1 Setup function\nThe first of these functions is called “setup” and takes no input arguments and has no return type indicated by the empty brackets and void data type. This function is where the programmer can put any code that only needs to be run once, examples include USB communication setup and port data direction configuration.\n\n\nB.5.2.2 Loop function\nThe second function is called “loop” and takes no input arguments and has no return type as above. This function is where the bulk of the code is written and as its name suggests will repeatedly execute the code inside the function block.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-5",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-5",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.6 Setting up I/O connections",
    "text": "B.6 Setting up I/O connections\n\nB.6.1 Step 3\nWithin the Arduino IDE, several library files containing useful definitions and functions are automatically included. One of these files contains a map of the memory address of each port register with masks that allow access to each bit/pin individually to labels that are the same as the connection label printed on the Arduino nano circuit board. Whilst this is convenient, it is good practice to define variables with more practical names which represent what is connected to them that the programmer can use throughout the program. A variable must be declared before it is used within the program and there are three different ways to achieve this:\n\nDeclare the variable at the start of the program before void setup (this is the best option)\nDeclare the variable at the start of the function (in this case, at the top of void loop)\nDeclare the variable inline.\n\nAs a minimum, the variable declaration must specify the data type and a name to be used, however this can also set the initial value of the variable. In the code, a variable is declared for each I/O connection of the circuit and given the value of the pin connection as follows:\n\nB.6.1.1 Variable definitions\n//Pin Definitions\nconst int pushButton = 8;\nconst int inputSignal = A0;\nconst int ledPin0 = 0;\nconst int ledPin1 = 1;\nconst int ledPin2 = 2;\nconst int ledPin3 = 3;\nconst int ledPin4 = 4;\nconst int ledPin5 = 5;\nconst int ledPin6 = 6;\nconst int ledPin7 = 7;\nFor example, the first of these declarations sets up the label “pushButton” in place of the value 8, this allows the programmer to use “pushButton” instead of the pin number when an operation needs to be performed.\nNote: In the above variable definitions the qualifier const is added at the start of each declaration. This tells the compiler this value is a constant and essentially makes it read-only8.\n\n\n\nB.6.2 Step 4\nThe next step is to set up the ports/pins that the external hardware is connected to including the data direction or mode and the default state of any outputs. \nWhen setting up the ports/pins, first set the data direction using the pre-defined Arduino function “pinMode”. This function takes two input arguments, the first is the connection label and the second is the mode itself. The syntax of this function is:\npinMode(pin, mode)\nwhere mode can be INPUT, OUTPUT, or INPUT_PULLUP. More information on this function can be found in the pinMode section of the Arduino reference library.\nImplementing the setup we described Section B.4 and using the names defined in Section B.6.1.1, the data direction/pinMode for the connections can be written as follows:\npinMode(pushButton, INPUT_PULLUP); // Default value is high, pressed value is low\npinMode(inputSignal, INPUT);\npinMode(ledPin0, OUTPUT);\npinMode(ledPin1, OUTPUT);\npinMode(ledPin2, OUTPUT);\npinMode(ledPin3, OUTPUT);\npinMode(ledPin4, OUTPUT);\npinMode(ledPin5, OUTPUT);\npinMode(ledPin6, OUTPUT);\npinMode(ledPin7, OUTPUT);\nThe default state of the LEDs can be set using the pre-defined Arduino function “digitalWrite”. This function takes two input arguments, the first is the connection label and the second is the value to set. The syntax of this function is:\ndigitalWrite(pin, value)\nwhere value can be HIGH or LOW. More information on this function can be found in the digitalWrite section of the Arduino reference library.\nImplementing the setup we described in Section B.4 and using the names defined in Section B.6.1.1, the code to set the initial state of the LEDs to off can be written as follows:\n//Set the initial state of the LEDs to be off\ndigitalWrite(ledPin0, LOW);\ndigitalWrite(ledPin1, LOW);\ndigitalWrite(ledPin2, LOW);\ndigitalWrite(ledPin3, LOW);\ndigitalWrite(ledPin4, LOW);\ndigitalWrite(ledPin5, LOW);\ndigitalWrite(ledPin6, LOW);\ndigitalWrite(ledPin7, LOW);",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#sec-programming-in-c-6",
    "href": "appendix/programming_in_c.html#sec-programming-in-c-6",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.7 Detecting and reacting to a button press",
    "text": "B.7 Detecting and reacting to a button press\n\nB.7.1 Step 5 - Detecting the Button Press\nNow the direction/mode for each pin and the initial state of the output pins has been set, the main program code can be written within the loop function. Looking back at the Section B.4\n\nThe program written needs to detect when a push button is pressed…“,\n\nthe first section of code within the loop function needs to check if the button has been pressed. This is achieved by reading the state of the pin and comparing against 0 or LOW, 0 is used since the pull-resistor for this pin has been enabled meaning the default value (no button press) seen at the input is 1 or HIGH.\nTo achieve this functionality in code, an if statement is used - The if statement allows branching within code and can be used to check if a particular condition has been met. If the condition has been met, the set of statements within the code block (parentheses) is executed, if the condition is not met then the statements within the code block are not executed and the program will branch over to the next statement outside of the if statement. The syntax of an if statement is\nif (condition is met) {\n  //statements to be run\n}\nTo read the current state of the pin, the pre-defined Arduino function “digitalRead” can be used. This function takes the connection label as an argument. The syntax of this function is:\ndigitalRead(pin)\nMore information on this function can be found in the digitalRead section of the Arduino reference library.\nTo check if the push button has been pressed, the equal to (==) comparison operator is used. This operator compares the value on the left with the value on the right and returns true when the two operands are equal.\nBy putting these three components together, and using the value LOW (or 0) on the right hand side of the “equal to” comparison operator, the following code checks whether the push button connected to D8 has been pressed:\nif (digitalRead(pushButton) == LOW) {\n    \n}\n\n\nB.7.2 Step 6 - Reading the Analog Input\nThe next step in this program is to write the code that can read the analogue signal and store the converted value into a variable. There are 2 parts to this step, the first is to declare a variable that the result will be stored in, and second, to read the analogue signal and assign the result to the declared variable. A variable must be declared before it is used and there are three different ways to achieve this:\n\nDeclare the variable at the start of the program before void setup (this is the best option)\nDeclare the variable at the start of the function (in this case, at the top of void loop)\nDeclare the variable inline.\n\nAs a minimum, the variable declaration must specify the data type and a name to be used, however this can also set the initial value of the variable. In code, we can declare a variable with the name sensorValue as follows:\n//Variable declarations\nint sensorValue = 0;\nNow the variable has been declared, the programmer/code can assign values to it and/or change its value. In this example, the programmer needs to read the value of the analogue input signal every time the push button is pressed. This means the next bit of code that is added needs to be within the code block of the button press detection.\nTo read the current value at an analogue pin, the pre-defined Arduino function “analogRead” can be used. This function takes the connection label as an argument. The syntax of this function is:\nanalogRead(pin)\nMore information on this function can be found in the analogRead section of the Arduino reference library.\nAdding this component to our existing code which checks whether the push button connected to D8 has been pressed, the code becomes:\nif (digitalRead(pushButton) == LOW) {\n    // read the value from the sensor and store the result in sensorValue variable\n    sensorValue = analogRead(inputSignal);\n}\nIn simple terms, each time the push button connected to D8 is pressed, the value of the input signal at A0 is read and stored in the variable sensorValue.\n\n\nB.7.3 Step 7 - Outputting the value of sensorValue to the LEDs\nThe initial task asked for a program that outputs the value of the analogue input signal as a proportion of the maximum value on a series of LEDs. In this application, 8 LEDs are connected to PORT D and variable names ledPin0 – ledPin7 have been declared. At this stage, the programmer needs to work out the relationship between the analogue input signal and each LED. The analogue input signal is being processed by the built in Analog to Digital Converter or ADC of the ATmega 328 microcontroller which has a 10 bit resolution meaning the digital output will be an integer value in the range of 0:1023 (\\(2^{10}-1\\)). Dividing the maximum digital value by the number of LEDs:\n\\[\\mathrm{EachLED} = \\frac{1023}{8} = 127.875\\]\nNow that the relationship between the output of the ADC and the LEDs is known the programmer can create the flow control statements to implement the output. This can be achieved by using an if, else-if statement with 8 test conditions as follows9:\nif (sensorValue &lt;= 127) {\n\n} else if (sensorValue &lt;= 255) {\n\n} else if (sensorValue &lt;= 383) {\n\n} else if (sensorValue &lt;= 511) {\n\n} else if (sensorValue &lt;= 639) {\n\n} else if (sensorValue &lt;= 767) {\n\n} else if (sensorValue &lt;= 895) {\n\n} else if (sensorValue &lt;= 1023) {\n\n}\nFinally, the programmer must populate each of these if statement blocks with the code to turn the correct LEDs on/off. Using the Arduino pre-defined functions there isn’t an elegant way to manipulate the state of the whole port meaning each of the above test cases will need 8 digitalWrite statements. The first test condition, should only switch the first LED on and as such is written as:\nif (sensorValue &lt;= 127) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, LOW);\n      digitalWrite(ledPin2, LOW);\n      digitalWrite(ledPin3, LOW);\n      digitalWrite(ledPin4, LOW);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n}\nOnce each of the test conditions has been populated with digitalWrite statements the code is complete and can uploaded to the Arduino Nano board.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#code-listing",
    "href": "appendix/programming_in_c.html#code-listing",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "B.8 Code Listing",
    "text": "B.8 Code Listing\nThe complete code listing for the example program is given in Listing B.1.\n\n\n\nListing B.1: An Example C Program\n\n\n//Pin Defintions\nconst int pushButton = 8;\nconst int inputSignal = A0;\nconst int ledPin0 = 0;\nconst int ledPin1 = 1;\nconst int ledPin2 = 2;\nconst int ledPin3 = 3;\nconst int ledPin4 = 4;\nconst int ledPin5 = 5;\nconst int ledPin6 = 6;\nconst int ledPin7 = 7;\n\n//Variable declarations\nint sensorValue = 0;\n\nvoid setup() {\n\n  // put your setup code here, to run once:\n  pinMode(pushButton, INPUT_PULLUP);  // Default value is high, pressed value is low\n  pinMode(inputSignal, INPUT);\n  pinMode(ledPin0, OUTPUT);\n  pinMode(ledPin1, OUTPUT);\n  pinMode(ledPin2, OUTPUT);\n  pinMode(ledPin3, OUTPUT);\n  pinMode(ledPin4, OUTPUT);\n  pinMode(ledPin5, OUTPUT);\n  pinMode(ledPin6, OUTPUT);\n  pinMode(ledPin7, OUTPUT);\n\n  //Set the initial state of the LEDs to be off\n  digitalWrite(ledPin0, LOW);\n  digitalWrite(ledPin1, LOW);\n  digitalWrite(ledPin2, LOW);\n  digitalWrite(ledPin3, LOW);\n  digitalWrite(ledPin4, LOW);\n  digitalWrite(ledPin5, LOW);\n  digitalWrite(ledPin6, LOW);\n  digitalWrite(ledPin7, LOW);\n}\n\n\nvoid loop() {\n  //if statement to test if pushButton has been pressed\n  //Default pushButton state is high as the pull-up resitor is enabled\n  if (digitalRead(pushButton) == LOW) {\n    // read the value from the sensor ans store the result in sensorValue variable\n    sensorValue = analogRead(inputSignal);\n\n    // Write to the LEDS\n    if (sensorValue &lt;= 127) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, LOW);\n      digitalWrite(ledPin2, LOW);\n      digitalWrite(ledPin3, LOW);\n      digitalWrite(ledPin4, LOW);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 255) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, LOW);\n      digitalWrite(ledPin3, LOW);\n      digitalWrite(ledPin4, LOW);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 383) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, LOW);\n      digitalWrite(ledPin4, LOW);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 511) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, HIGH);\n      digitalWrite(ledPin4, LOW);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 639) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, HIGH);\n      digitalWrite(ledPin4, HIGH);\n      digitalWrite(ledPin5, LOW);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 767) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, HIGH);\n      digitalWrite(ledPin4, HIGH);\n      digitalWrite(ledPin5, HIGH);\n      digitalWrite(ledPin6, LOW);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 895) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, HIGH);\n      digitalWrite(ledPin4, HIGH);\n      digitalWrite(ledPin5, HIGH);\n      digitalWrite(ledPin6, HIGH);\n      digitalWrite(ledPin7, LOW);\n    } else if (sensorValue &lt;= 1023) {\n      digitalWrite(ledPin0, HIGH);\n      digitalWrite(ledPin1, HIGH);\n      digitalWrite(ledPin2, HIGH);\n      digitalWrite(ledPin3, HIGH);\n      digitalWrite(ledPin4, HIGH);\n      digitalWrite(ledPin5, HIGH);\n      digitalWrite(ledPin6, HIGH);\n      digitalWrite(ledPin7, HIGH);\n    }\n  }\n}\n\n\n\nThe complete code listing can be downloaded as a GitHub gist example.ino.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "appendix/programming_in_c.html#footnotes",
    "href": "appendix/programming_in_c.html#footnotes",
    "title": "Appendix B — Programming in C – from nothing to software",
    "section": "",
    "text": "When considering the physical set up of this the programmer/engineer must ensure that the maximum possible value seen at the microcontroller input is less than or equal to the reference voltage of our Analogue to Digital Converter (ADC) to prevent an overvoltage.↩︎\nIn order to clearly detect the button press and avoid floating voltages the programmer needs to ensure the pull up resistor for the specific pin is enabled (or that this has been implemented separately in hardware).↩︎\nthe programmer could also use D9, D10, D11, D12 etc.↩︎\nthe programmer could also use A1, A2, A3, A4, etc.)↩︎\npins across multiple ports can be used but this will make the programming more complicated.↩︎\nWhen building this circuit, it is advised that the red wire from the 5V output of the Arduino nano board to the bottom rail of the breadboard is replaced with a 220 Ohm resistor, this will protect the USB circuitry within the PC in the event of any wiring faults/short circuits between the rails.↩︎\nThe IDE set-up instructions given here are for windows. Additional hardware specific intructions are given in {ref}set_up_arduino and in the Platform specific guides. :w↩︎\nIf a value will not change, it can be stored as part of the program in read-only-memory. This will release a small amount of space in working memory which is often limited in a microcontroller.↩︎\nTo avoid using floating point aritmetic, we have rounded \\(127.875\\) to \\(127\\). If you wanted to be really accurate, you could add the full value and round afterwards. For example \\(2\\times 127.875 = 256\\); \\(3\\times 127.875 = 384\\). Indeed it is arguable that \\(127.875\\) is closer to \\(128\\) than \\(127\\)!↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Programming in C &ndash; from nothing to software</span>"
    ]
  },
  {
    "objectID": "lectures/index.html",
    "href": "lectures/index.html",
    "title": "Microcontrollers Lectures",
    "section": "",
    "text": "List of Lectures",
    "crumbs": [
      "Microcontrollers Lectures"
    ]
  },
  {
    "objectID": "lectures/index.html#list-of-lectures",
    "href": "lectures/index.html#list-of-lectures",
    "title": "Microcontrollers Lectures",
    "section": "",
    "text": "Croeso i Brifysgol Abertawe | Welcome to Swansea University\nLecture 1: Introduction to Microcontrollers and Microcontroller Architecture\nSelf-study: Introduction to Data Representation\nLecture 2: Architecture of the Atmel ATmega 328 Microcontroller\nLecture 3: Introduction to Programming and Program Development\nLecture 4: Introduction to Programming with C\nLecture 5: Interfacing to digital I/O with C\nLecture 6: Interfacing to analogue I/O with C\nLecture 7: Introduction to Assembly Language\nLecture 8: Microcontroller Architecture – Program Operation\nLecture 9: Addressing Modes",
    "crumbs": [
      "Microcontrollers Lectures"
    ]
  },
  {
    "objectID": "lab_intro/intro.html",
    "href": "lab_intro/intro.html",
    "title": "Laboratory Introduction",
    "section": "",
    "text": "Table of contents\nYou should work through each of these activities in order.\nIf you would prefer a document version of the lab introduction, it is available as a PDF which you are welcome to download and use.\nHowever, so your progress in the lab can be monitored, you are expected to work through the sections on Canvas.",
    "crumbs": [
      "Laboratory Introduction"
    ]
  },
  {
    "objectID": "lab_intro/intro.html#table-of-contents",
    "href": "lab_intro/intro.html#table-of-contents",
    "title": "Laboratory Introduction",
    "section": "",
    "text": "Assessment of the Laboratory Introduction\nLaboratory Work in the Department of Electronic and Electrical Engineering\nLaboratory Instruments\nLaboratory Safety\nObtain and Keep a Lab Diary - External Link to Canvas\nExperiment: to construct an oscillator\nSimulation Exercise\nQuestions\nConstruction Exercise - Continuity Tester\nSafe Soldering",
    "crumbs": [
      "Laboratory Introduction"
    ]
  },
  {
    "objectID": "labs/index.html",
    "href": "labs/index.html",
    "title": "Microcontroller Programming Laboratory",
    "section": "",
    "text": "Lab Experiments\nThe Microcontroller Laboratory consists of a getting started introduction, plus the five assessable experiments listed below.",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "labs/index.html#lab-experiments",
    "href": "labs/index.html#lab-experiments",
    "title": "Microcontroller Programming Laboratory",
    "section": "",
    "text": "Getting Started\nExperiment 1: Binary Counter\nExperiment 2: Digital Input\nExperiment 3: Analogue to Digital Conversion\nExperiment 4: Arrays\nExperiment 5: LCD Display Panel",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "labs/index.html#assessment-of-the-microcontroller-laboratory",
    "href": "labs/index.html#assessment-of-the-microcontroller-laboratory",
    "title": "Microcontroller Programming Laboratory",
    "section": "Assessment of the Microcontroller Laboratory",
    "text": "Assessment of the Microcontroller Laboratory\nThe mark for each of the experiments is a maximum of five points, making a total of 25 marks – 25% of the assessment for the whole module.\nAssessment will be based on a Laboratory (Lab) Diary. Many other lab-based modules are assessed this way, including EG-152 Electronic Circuits next term, and the two practical labs in second year, EGA222 and EGA223.",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "labs/index.html#sec-lab-diary",
    "href": "labs/index.html#sec-lab-diary",
    "title": "Microcontroller Programming Laboratory",
    "section": "About the Lab Diary",
    "text": "About the Lab Diary\nWhat is a laboratory diary?\nIn the “old days” this would have taken the form of a hard-backed notebook, called a logbook, and all results, calculations and other details of the experiments would be meticulously written in the logbook. This is the 21st Century, and we now use an electronic logbook which we call a Lab Diary.\nThe lab diary takes the form of a Word document or similar, in which all the details of an experiment are recorded. This might include tables of results, graphs or calculations based on the results, screen shots from the Lab PC or the R&S oscilloscope, photos of the equipment, anything that helps someone reading the diary (including your yourself) to see what was done. In addition, if you are asked to write a report on a particular subject (for example, in EG-152, EGA222 and EGA223) then the lab diary is the source of information for each experiment. You should not need to go back to the laboratory to repeat parts of the experiment. More information about lab diaries, including an example and template is given on Canvas on the page ✅ To Do: Obtain and Keep a Lab Diary 📓.\nThe script for each of the experiments will tell you what is required for each experiment. In general, this will be program listings (properly formatted and with copious comments, of course!) and some measurements and calculations based on the results. The lab diary will be submitted later in the term for assessment. It recommended that you convert the submitted version of the diary to pdf, so that we see your document without changes caused by printer drivers, different versions of WORD, and so on.",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "labs/index.html#questions-and-discussion",
    "href": "labs/index.html#questions-and-discussion",
    "title": "Microcontroller Programming Laboratory",
    "section": "Questions and Discussion",
    "text": "Questions and Discussion\nIf you have questions about any aspect of the Microcontroller Programming Laboratory, please visit the discussion board on Canvas:💬 ❓ 🧪 Discussion and Questions about the Microcontroller Programming Lab Exercises. See also 💬 ❓ 📓 Discussion and Questions about Lab Diaries.",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "labs/index.html#good-luck",
    "href": "labs/index.html#good-luck",
    "title": "Microcontroller Programming Laboratory",
    "section": "Good luck!",
    "text": "Good luck!\nGood luck with the EG-151 microcontroller programming experiments!\n\n\n\nDr. Chris Jobling, Module Coordinator\n\n\nDr. Timothy Davies, Creator of the Lab\n\n\nDr. Ben Clifford, Former Module Lecturer\n\n\nDr. Hayder Jahanger, Module Lecturer",
    "crumbs": [
      "Microcontroller Programming Laboratory"
    ]
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Mini Projects",
    "section": "",
    "text": "Introduction\nThe Mini Project builds on the experience gained in the microcontroller experiments (Microcontroller Programming Laboratory) that occupy the first part of the course. It gives you an opportunity to use your knowledge to build an open-ended project for a specific, practical purpose. At the heart of the mini project is still the Arduino Nano microcontroller, but additional parts will be made available. You will work in groups of four on your mini project, and you will return a single report on what you have achieved.",
    "crumbs": [
      "Mini Projects"
    ]
  },
  {
    "objectID": "projects/index.html#alphanumeric-display-module",
    "href": "projects/index.html#alphanumeric-display-module",
    "title": "Mini Projects",
    "section": "Alphanumeric Display module",
    "text": "Alphanumeric Display module\nThe first step in the Mini Project is to complete Experiment 5: LCD Display Panel, as the alphanumeric display module will be central to the project, in order to display information from sensors, for example temperature readings.",
    "crumbs": [
      "Mini Projects"
    ]
  },
  {
    "objectID": "projects/index.html#demonstration-program",
    "href": "projects/index.html#demonstration-program",
    "title": "Mini Projects",
    "section": "Demonstration Program",
    "text": "Demonstration Program\nThe demonstration program introduced in Experiment 5: LCD Display Panel contains examples of how to display ASCII text, such as “Hello World”, and how to represent inputs from digital sources, such as the push buttons. Most importantly, it shows how to display variables such as time and analogue inputs.",
    "crumbs": [
      "Mini Projects"
    ]
  },
  {
    "objectID": "projects/index.html#assessment-of-the-mini-project",
    "href": "projects/index.html#assessment-of-the-mini-project",
    "title": "Mini Projects",
    "section": "Assessment of the Mini-Project",
    "text": "Assessment of the Mini-Project\nThe mini projects will be allocated near the end of the laboratory exercises. Each team will be given a task to perform, which will require that some additional hardware be connected to the Arduino on the plug-in breadboard. Near the end of term, the mini-projects will be assessed by staff members at the laboratory bench. This part of the assessment carries 10 marks.\nFor example, suppose a mini-project team has decided to build a digital voltmeter. If the finished item does not work a mark of less than 40% of the maximum will be awarded. If the voltmeter works but the number displayed is not calibrated, then a mark of 40-50% will be awarded. If the voltmeter works and has additional functionality, e.g. averaging and correct calibration, this will receive a mark of 50-70%. Marks greater than 70% will require some really clever additional features, such as bipolar input voltage, offset zero, memory and so on.\nIn addition to the one-to-one assessment of the mini-project, each team will submit a report worth a further 20 marks which should contain the following:\n\nNames of team members.\nTitle of Project.\nIntroduction; the task set, and how it was approached.\nTechnical details such as additional circuits and input-output pin assignment.\nA flow chart of the program.\nA conclusion, in which the team members can reflect on how the project could be improved, possible alternatives and so on.\n\nThe format of the report is left open and up to you: a formal document, PowerPoint presentation, poster, video, podcast etc, would all be acceptable providing that the assessment points are covered.",
    "crumbs": [
      "Mini Projects"
    ]
  },
  {
    "objectID": "projects/index.html#possible-titles-for-the-mini-projects",
    "href": "projects/index.html#possible-titles-for-the-mini-projects",
    "title": "Mini Projects",
    "section": "Possible titles for the mini projects",
    "text": "Possible titles for the mini projects\nFor possible projects titles, see the following pages.\n\nVoltmeter\nUltrasonic Range Finder\nClock Time\nWeather Station\n\n\nDr. Chris Jobling and the EG-151 team, November 2024",
    "crumbs": [
      "Mini Projects"
    ]
  }
]